<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="深入理解Java虚拟机总结"/>




  <meta name="keywords" content="jvm," />




  <link rel="alternate" href="/atom.xml" title="Zone">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.1.0" />



<link rel="canonical" href="https://luhaoaimama1.github.io/2016/12/05/JVM/"/>


<meta name="description" content="基础了解
各种基本类型:boolean、byte、char、short、int、float、long、double;
对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针
局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;
额外了解:插入式注解处理器:需要继承AbstractProcessor;">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Java虚拟机总结">
<meta property="og:url" content="https://luhaoaimama1.github.io/2016/12/05/JVM/index.html">
<meta property="og:site_name" content="Zone">
<meta property="og:description" content="基础了解
各种基本类型:boolean、byte、char、short、int、float、long、double;
对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针
局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;
额外了解:插入式注解处理器:需要继承AbstractProcessor;">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tKfTcgw1fb913k1wc0j30f50a53zv.jpg">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tKfTcgw1fb91bux68qj31f016w41s.jpg">
<meta property="og:image" content="https://ww3.sinaimg.cn/large/006tKfTcgw1fb913u4clkj317k0h6abh.jpg">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9143ha08j30cx08zmx7.jpg">
<meta property="og:image" content="https://ww2.sinaimg.cn/large/006tKfTcgw1fb914owdnxj30ii0c2t9t.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tKfTcgw1fb915j8lkhj30ik0bi0tt.jpg">
<meta property="og:image" content="https://ww3.sinaimg.cn/large/006tKfTcgw1fb915o8c50j30in0bcab3.jpg">
<meta property="og:image" content="https://ww2.sinaimg.cn/large/006tKfTcgw1fb9166bymyj30e00b5wfn.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tKfTcgw1fb9160tldaj31kw0jgacz.jpg">
<meta property="og:image" content="https://ww1.sinaimg.cn/large/006tKfTcgw1fb916pqo7bj30lm09taas.jpg">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9170p4unj30b5087gm9.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201602/616953-20160226111115693-1490327308.png">
<meta property="og:image" content="http://images0.cnblogs.com/blog2015/544748/201505/251937420687138.jpg">
<meta property="og:image" content="https://ww4.sinaimg.cn/large/006tKfTcgw1fb917dq0h0j30hs0cd775.jpg">
<meta property="og:updated_time" content="2016-12-30T12:10:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Java虚拟机总结">
<meta name="twitter:description" content="基础了解
各种基本类型:boolean、byte、char、short、int、float、long、double;
对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针
局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;
额外了解:插入式注解处理器:需要继承AbstractProcessor;">
<meta name="twitter:image" content="https://ww1.sinaimg.cn/large/006tKfTcgw1fb913k1wc0j30f50a53zv.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.1.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />





    <title> 深入理解Java虚拟机总结 · Zone </title>
  </head>

  <body>
    <div class="container">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Zone</a>
</div>

<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            分类
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/about">
            关于
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/message">
            留言
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/github">
            项目
          </a>
        </li>
      
        
        <li class="menu-item">
          <a class="menu-item-link" href="/friendlinks">
            外联
          </a>
        </li>
      
      
        <li class="menu-search">
          <form>
            <i class="iconfont icon-search" id="open-search"></i>
            <input type="text" class="search-input" id="search-input" />
            <i class="iconfont icon-close" id="close-search"></i>
          </form>
        </li>
      
    </ul>
  
</nav>

<div class="mobile-navbar">
  <div class="mobile-header">
    <div class="mobile-header-logo">
      <a href="/." class="logo">Zone</a>
    </div>

    <div class="mobile-header-icon">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <nav class="mobile-menu">
    
      
      <a class="mobile-menu-item" href="/">
        首页
      </a>
    
      
      <a class="mobile-menu-item" href="/archives/">
        归档
      </a>
    
      
      <a class="mobile-menu-item" href="/categories">
        分类
      </a>
    
      
      <a class="mobile-menu-item" href="/about">
        关于
      </a>
    
      
      <a class="mobile-menu-item" href="/message">
        留言
      </a>
    
      
      <a class="mobile-menu-item" href="/github">
        项目
      </a>
    
      
      <a class="mobile-menu-item" href="/friendlinks">
        外联
      </a>
    
  </nav>
</div>
      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          深入理解Java虚拟机总结
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016年12月5日
        </span>
      </div>
    </header>

    
      <div class="post-toc" id="post-toc">
        <h2 class="post-toc-title">文章目录</h2>
        <div class="post-toc-content">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础了解"><span class="toc-text">基础了解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理机制"><span class="toc-text">内存管理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm各个区域的概要"><span class="toc-text">jvm各个区域的概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象访问定位"><span class="toc-text">对象访问定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的布局"><span class="toc-text">对象的布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标记概要"><span class="toc-text">标记概要</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#标记算法"><span class="toc-text">标记算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四种引用"><span class="toc-text">四种引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#不可达对象的最后历程"><span class="toc-text">不可达对象的最后历程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾收集算法"><span class="toc-text">垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#标记-清除算法-基础算法-剩下的都是基于它的不足而进行改进的"><span class="toc-text">标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制-Copying-算法"><span class="toc-text">复制(Copying)算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标记-整理-Mark-Compact-算法-老年代常用"><span class="toc-text">标记-整理(Mark-Compact)算法(老年代常用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分代收集算法"><span class="toc-text">分代收集算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#垃圾收集器"><span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7种垃圾收集器的介绍"><span class="toc-text">7种垃圾收集器的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#理解一下GC日志"><span class="toc-text">理解一下GC日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空间分配担保"><span class="toc-text">空间分配担保</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机参数设置"><span class="toc-text">虚拟机参数设置;</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类的初始化过程"><span class="toc-text">类的初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#非法向前引用"><span class="toc-text">非法向前引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类什么时候才被初始化"><span class="toc-text">类什么时候才被初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双亲委派模型"><span class="toc-text">双亲委派模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#静态分派与动态分派"><span class="toc-text">静态分派与动态分派</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#静态分派"><span class="toc-text">静态分派</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态分派"><span class="toc-text">动态分派</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态加载"><span class="toc-text">动态加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java魔法糖"><span class="toc-text">Java魔法糖</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型与擦除"><span class="toc-text">泛型与擦除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#高效并发"><span class="toc-text">高效并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile型变量的特殊规则"><span class="toc-text">volatile型变量的特殊规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java线程调度"><span class="toc-text">Java线程调度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference-amp-Thanks："><span class="toc-text">Reference&Thanks：</span></a></li></ol>
        </div>
      </div>
    

    <div class="post-content">
      
        <h1 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h1><ul>
<li>各种基本类型:boolean、byte、char、short、int、float、long、double;</li>
<li>对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针</li>
<li>局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;</li>
<li>额外了解:插入式注解处理器:需要继承AbstractProcessor;</li>
</ul>
<a id="more"></a>
<h1 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h1><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb913k1wc0j30f50a53zv.jpg" alt=""></p>
<blockquote>
<p>本地方法栈和虚拟机栈有的虚拟机是不分的;</p>
</blockquote>
<p><a id="way1-1"></a></p>
<h2 id="jvm各个区域的概要"><a href="#jvm各个区域的概要" class="headerlink" title="jvm各个区域的概要"></a>jvm各个区域的概要</h2><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb91bux68qj31f016w41s.jpg" alt=""></p>
<p><a id="way1-2"></a></p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb913u4clkj317k0h6abh.jpg" alt=""></p>
<blockquote>
<p>句柄优势:reference本身不需要修改,只会改变句柄中的实例数据指针</p>
<p>直接指针访问优势:最大好处速度快。节省了一次指针定位的开销;</p>
<p>HotSpot采用此方式</p>
</blockquote>
<p><a id="way1-3"></a></p>
<h2 id="对象的布局"><a href="#对象的布局" class="headerlink" title="对象的布局"></a>对象的布局</h2><p>3个区域:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p>
<blockquote>
<p>header:(官方称 Mark Word)运行时数据,入哈希码(HashCode)、GC分代年龄 锁状态标识</p>
<p>Instance Data:类型指针,既对象只想他的类元数据的指针;</p>
<p>Padding:因为对象的大小必须是8字节的整数倍。如果数据没有对齐。需要Padding来补全</p>
</blockquote>
<p>#垃圾收集器与内存分配策略</p>
<ul>
<li>主要思考的问题:<ul>
<li>标记-那些内存(那些死,那些活着)需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
</li>
</ul>
<p><a id="way2-1"></a></p>
<h1 id="标记概要"><a href="#标记概要" class="headerlink" title="标记概要"></a>标记概要</h1><h2 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h2><p>1)引用计数法(不能用):每当一个地方引用它时,计数器+1,引用失效时,计数器-1,任何时刻计数器为0的对象就是不可能在被使用</p>
<blockquote>
<p>java没有用 最主要的原因很难解决对象之间互相循环引用的问题;</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object instance=<span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ReferenceCountingGC objA=  <span class="keyword">new</span> <span class="type">ReferenceCountingGC</span>();</div><div class="line">        ReferenceCountingGC objB=  <span class="keyword">new</span> <span class="type">ReferenceCountingGC</span>();</div><div class="line">        objA.instance=objB;</div><div class="line">        objB.instance=objA;</div><div class="line">        objA=<span class="literal">null</span>;</div><div class="line">        objB=<span class="literal">null</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2)可达性分析算法:<br><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9143ha08j30cx08zmx7.jpg" alt=""></p>
<ul>
<li>Java 语言中,可作为GC Roots的对象包括下面几种;<ul>
<li>虚拟机栈中(栈帧中的本地变量表)的引用对象</li>
<li>方法区中类静态属性引用对象</li>
<li>方法区中类常量引用对象</li>
<li>本地方法栈JNI引用的对象</li>
</ul>
</li>
</ul>
<p><a id="way2-2"></a></p>
<h2 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h2><ul>
<li>引用分为四种 强,软,弱,虚四种 强度依次减弱<ul>
<li>强引用:类似Object obj=new Object() 这类引用,只要强引用还在,垃圾收集器就永远不会回收被引用的对象;</li>
<li>软引用:用来描述一些还有用但并未必须的对象。内存溢出异常之前,会把这些对象列入回收范围之内进行二次回收。如果回收后还没有足够的内存这回OOM;</li>
<li>弱引用:用来描述非必须的对象。若引用关联的对象只能活到下一次垃圾回收之前;</li>
<li>虚引用:唯一目的对象被回收时收到一个系统通知</li>
</ul>
</li>
</ul>
<p><a id="way2-3"></a></p>
<h2 id="不可达对象的最后历程"><a href="#不可达对象的最后历程" class="headerlink" title="不可达对象的最后历程"></a>不可达对象的最后历程</h2><blockquote>
<p>总结:finalize()方法不执行或者只能执行一次</p>
</blockquote>
<p>不可达对象,也并非”非死不可” 这时候是在缓刑阶段。要真正宣告死亡,至少要经理两次标记过程。<br>如果对象进行可达性分析后发现没有GC Roots相关联的引用链,会被第一次标记并且进行一次筛选,筛选条件是此对象是否有必要执行finalize()方法。<br>对象没有覆盖finalize方法(逃脱命运的最后机会),或者<strong>finalize()方法被虚拟机掉用过(只能执行一次)</strong>,虚拟机将这两种情况都视为”没有必要执行”<br>如果被判定有必要执行,那么对象会放置叫一个F-Queue的队列之中,并且稍后虚拟机自动建立Finalize线程去执行它既finalize方法<br>但并不承诺会等待他运行结束,怕死循环或者运行缓慢。finalize方法是逃脱命运的最后机会,如果没有逃脱就真的被回收了;</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p><a id="way3-1"></a></p>
<h2 id="标记-清除算法-基础算法-剩下的都是基于它的不足而进行改进的"><a href="#标记-清除算法-基础算法-剩下的都是基于它的不足而进行改进的" class="headerlink" title="标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)"></a>标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)</h2><p>标记:标记所有需要回收的对象</p>
<p>清除:统一回收所有被标记的对象</p>
<blockquote>
<p>不足1:效率问题,标记和清除效率都不高;<br>不足2:空间问题,产生大量的不连续的内存碎片</p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb914owdnxj30ii0c2t9t.jpg" alt=""><br><a id="way3-2"></a></p>
<h2 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h2><p>内存容量划分两个大小相等的两块,每次使用其中的一块。这块用完了复制存活的对象到另一块,在把这块清理掉</p>
<blockquote>
<p>不足:代价太高 把内存缩小为原来的一半;</p>
</blockquote>
<p>现代的商用虚拟街都采用这种算法来回收新生代;因为新生代都是 <strong>朝生暮死</strong> 所以不需要1:1来划分<br>而将内存分为一块较大的Eden 和两个较小的Survivor 默认大小比;8:1, 每次新生代中可用的内存空间是整个新生代容量的90=(Eden+Survivor),<br>“浪费” 10 因为没办法保证回收只有不多于10的存活,Survivor空间不够需要老年代进行 担保;<br><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb915j8lkhj30ik0bi0tt.jpg" alt=""><br><a id="way3-3"></a></p>
<h2 id="标记-整理-Mark-Compact-算法-老年代常用"><a href="#标记-整理-Mark-Compact-算法-老年代常用" class="headerlink" title="标记-整理(Mark-Compact)算法(老年代常用)"></a>标记-整理(Mark-Compact)算法(老年代常用)</h2><p>标记和以前一样,后续步骤不是直接回收,而是存活对象向一端移动,然后清理边界以外的内存;<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb915o8c50j30in0bcab3.jpg" alt=""><br><a id="way3-4"></a></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期将内存划分不同的几块。一般堆分为 新生代 和老年代。这样根据年代的特点采用最适当的收集算法</p>
<p>新生代:少量存活 选择复制算法</p>
<p>老年代:存活率高,没有额外空间担保,必须使用 标记清理 或者标记整理;</p>
<blockquote>
<p>GC会产生停顿(Sun也叫它 “Stop The World”),OoMap 存放着GC Roots,不是每条指令都生成一个。</p>
<p>不是任何时都能停下来进行 GC ,只有在 “特定的位置” 才可以GC 这个位置也叫安全点(Safepoint)</p>
<p>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定的</p>
</blockquote>
<p>关于安全点另一个需要考虑的就是如何在GC发生的时让所有线程都”跑”到最近的安全点上在停下来;有两种方案</p>
<p>抢先式中断(Preemptive Suspension)(现在几乎都这种方案):不需要线程的执行代码主动配合,GC发生时候先把线程全部中断,如果有线程不在安全点,就回复线程让它跑到安全点。</p>
<p>主动式中断(Voluntary Suspension):当GC需要中断线程的时候,不对线程造作,仅仅简单地设置一个标志位,各个线程执行的时候主动去轮询这个标志位,发现中断标志位真就挂起,轮询标志的地方安全点重合。<br>而对于不执行的线程,任何时间都是安全的也称为安全区;</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><a id="way4-1"></a></p>
<h2 id="7种垃圾收集器的介绍"><a href="#7种垃圾收集器的介绍" class="headerlink" title="7种垃圾收集器的介绍"></a>7种垃圾收集器的介绍</h2><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb9166bymyj30e00b5wfn.jpg" alt=""><br><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb9160tldaj31kw0jgacz.jpg" alt=""></p>
<blockquote>
<p>G1收集器因为没有商用的就不写了;</p>
</blockquote>
<p>Serial:单线程收集器，在进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束。</p>
<blockquote>
<ol>
<li><p>需要STW（Stop The World），停顿时间长。</p>
</li>
<li><p>简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。</p>
</li>
</ol>
</blockquote>
<p>ParNew:是Serial的多线程版本，除了使用多线程进行垃圾收集外，其他行为与Serial完全一样</p>
<blockquote>
<p>Tips：1.Server模式下虚拟机的首选新生收集器，与CMS进行搭配使用。</p>
</blockquote>
<p>Parallel Scavenge:目标是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，并且虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应调节策略。<br>Serial Old:老年代的单线程收集器，使用标记 - 整理算法，<br>Parallel Old:老年代的多线程收集器，使用标记 - 整理算法，吞吐量优先，适合于Parallel Scavenge搭配使用</p>
<ul>
<li>CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：<ul>
<li>初始标记，标记GCRoots能直接关联到的对象，时间很短。</li>
<li>并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。</li>
<li>重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。</li>
<li>并发清除，回收内存空间，时间很长。<blockquote>
<p>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行<br>Tips：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li><p>无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。</p>
</li>
<li><p>由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。</p>
</li>
</ol>
</blockquote>
<p><a id="way4-2"></a></p>
<h2 id="理解一下GC日志"><a href="#理解一下GC日志" class="headerlink" title="理解一下GC日志"></a>理解一下GC日志</h2><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="name">GC</span> (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">6270</span>K-&gt;584K(<span class="name">9216K</span>)] <span class="number">11390</span>K-&gt;5712K(<span class="name">19456K</span>), <span class="number">0.0011969</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<ol>
<li>[GC (System.gc())]与[Full GC (System.gc())]，说明垃圾收集的停顿类型，不是区分新生代GC和老年代GC的，如果有Full，则表示此次GC发生了Stop The World。</li>
<li>PSYoungGen: 6270K-&gt;584K(9216K)，表示，新生代：该内存区域GC前已使用容量 -&gt; 该内存区域GC后已使用容量（该内存区域总容量）</li>
<li>11390K-&gt;5712K(19456K)，表示，GC前Java堆已使用的容量 -&gt; GC后Java堆已使用的容量（Java堆总容量）</li>
<li>0.0011969 secs，表示GC所占用的时间，单位为秒。</li>
<li>[Times: user=0.00 sys=0.00, real=0.00 secs]，表示GC的更具体的时间，user代表用户态消耗的CPU时间，sys代表内核态消耗的CPU时间，real代表操作从开始到结束所经过的墙钟时间。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，如等待磁盘IO，等待线程阻塞，CPU时间则不包含这些耗时。当系统有多CPU或者多核时，多线程操作会叠加这些CPU时间，所以读者看到user或者sys时间超过real时间也是很正常的</li>
</ol>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb916pqo7bj30lm09taas.jpg" alt=""></p>
<ul>
<li>GC类型<ul>
<li>Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li>Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。</li>
<li>Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</li>
</ul>
</li>
</ul>
<p>大对象直接进入老年代:大对象就是大量连续内存空间的Java对象,典型的就是很长的字符串及数组。并且内存超过虚拟机设置大对象的值;</p>
<p>长期存活的对象进入老年代:jvm给每个对象定义一个对象年龄计数器。如果eden出生并经过第一次Minor GC后仍然存活并且能被Survivor容纳的话,将被移动到Survivor空间并将对象年龄设为1.对象在Survivor区每”熬过”一次Minor GC则年龄+1,当年龄达到一定程度(默认15岁),下一次将会被晋升老年代。</p>
<p>动态对象年龄判定:为了更好的适应内存状况。如果在Survivor空间中相同年龄的所有对象大小的综合大于Survivor的一半,那么大于等于这个年龄的将被一起带入老年代</p>
<blockquote>
<p>Tips:研究代码对象到底怎么回收请看Page:93(深入理解JVM虚拟机第二版)</p>
</blockquote>
<p><a id="way4-3"></a></p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9170p4unj30b5087gm9.jpg" alt=""></p>
<p><a id="way4-4"></a></p>
<h2 id="虚拟机参数设置"><a href="#虚拟机参数设置" class="headerlink" title="虚拟机参数设置;"></a>虚拟机参数设置;</h2><p>代码的运行参数设置为： -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8<br><img src="http://images2015.cnblogs.com/blog/616953/201602/616953-20160226111115693-1490327308.png" alt=""></p>
<h1 id="类的初始化过程"><a href="#类的初始化过程" class="headerlink" title="类的初始化过程"></a>类的初始化过程</h1><p><img src="http://images0.cnblogs.com/blog2015/544748/201505/251937420687138.jpg" alt=""></p>
<p><a id="way5-1"></a></p>
<h2 id="非法向前引用"><a href="#非法向前引用" class="headerlink" title="非法向前引用"></a>非法向前引用</h2><p>编译器手机的顺序是由语句在源文件中出现的顺序决定的,静态语句块中只能访问到定义在静态语句之前的变量,定义它之后的变量,可以赋值,但不能访问</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">         i=<span class="number">0</span>;</div><div class="line">         system.<span class="keyword">out</span>.print(i);<span class="comment">//非法向前引用</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><clinit>(类构造器方法):如果类或者接口没有静态语句块,也没有对变量的赋值,那么编译器可以不为这个类生成<clinit>方法并且他被加锁了 </clinit></clinit></p>
<p>Tips:如果在此方法中耗时很长,就可能造成多个进程阻塞;</p>
</blockquote>
<p><a id="way5-2"></a></p>
<h2 id="类什么时候才被初始化"><a href="#类什么时候才被初始化" class="headerlink" title="类什么时候才被初始化"></a>类什么时候才被初始化</h2><ul>
<li>只有这6中情况才会导致类的类的初始化<ul>
<li>1创建类的实例，也就是new一个对象</li>
<li>2访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>3调用类的静态方法</li>
<li>4反射（Class.forName(“com.lyj.load”)）</li>
<li>5初始化一个类的子类（会首先初始化子类的父类）</li>
<li>6JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
</li>
<li>类的初始化步骤：<ul>
<li>1如果这个类还没有被加载和链接，那先进行加载和链接</li>
<li>2假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）</li>
<li>3加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</li>
</ul>
</li>
</ul>
<p><a id="way5-3"></a>         </p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>Java虚拟器角度仅仅有两种不同的类加载器:</p>
<p>一种启动类加载器(Bootstrap ClassLoader):C++语言实现是虚拟器自身的一部分;</p>
<p>另一种是所有其他的类加载器(java语言,JVM之外 继承ClassLoader)</p>
<blockquote>
<p>更详细:</p>
</blockquote>
<p>!<img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb917dq0h0j30hs0cd775.jpg" alt=""></p>
<p>Bootstrap ClassLoader:负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p>
<p>Extension ClassLoader:负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p>
<p>App ClassLoader:负责记载classpath中指定的jar包及目录中class</p>
<p>Custom ClassLoader:属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p>
<blockquote>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
</blockquote>
<p><a id="way5-3-1"></a></p>
<p>###为什么这么设计?</p>
<p>类加载器:任何一个类都需要加载它的类加载器和这个类一同确立其在java虚拟机唯一性。每个类加载器都有类名称空间。</p>
<blockquote>
<p>两个类是否相同,是由同一个类加载器为前提下才有意义.相同是指equals、instanceof isAssignalbeFrom isIntance等;</p>
</blockquote>
<p>例如类java.lang.Object,他存放在rt.jar中,无论哪个类加载器加载这个类,最终都是委派给魔性最顶端的启动类加载器进行加载。因此Object类在程序的各种类加载器环境中都是<strong>同一个类</strong>。<br>相反如果没有使用,各个类加载自行加载的话。那么系统将出现多个不同的Object类,那么java类型体系中最基本的行为也无法保证;</p>
<p>以下是ClassLoader的源码,实现很简单<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">rotected synchronized <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">loadClass</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">boolean</span> <span class="title">resolve</span>)</span></div><div class="line">	throws ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">	// First, check <span class="keyword">if</span> the <span class="class"><span class="keyword">class</span> <span class="title">has</span> <span class="title">already</span> <span class="title">been</span> <span class="title">loaded</span></span></div><div class="line">	<span class="class"><span class="keyword">Class</span> <span class="title">c</span> = <span class="title">findLoadedClass</span>(<span class="title">name</span>);</span></div><div class="line">	<span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</div><div class="line">	    <span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</div><div class="line">		    //从父加载器加载</div><div class="line">		    c = parent.loadClass(name, <span class="literal">false</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		    //从bootstrap loader加载</div><div class="line">		    c = findBootstrapClassOrNull(name);</div><div class="line">		&#125;</div><div class="line">	    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                // ClassNotFoundException thrown <span class="keyword">if</span> <span class="class"><span class="keyword">class</span> <span class="title">not</span> <span class="title">found</span></span></div><div class="line">                // from the non-<span class="literal">null</span> parent <span class="class"><span class="keyword">class</span> <span class="title">loader</span></span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</div><div class="line">	        // <span class="keyword">If</span> still <span class="keyword">not</span> found, <span class="keyword">then</span> invoke findClass in order</div><div class="line">	        // <span class="keyword">to</span> find the <span class="class"><span class="keyword">class</span>.</span></div><div class="line">	        c = findClass(name);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (resolve) &#123;</div><div class="line">	    resolveClass(c);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>1.2以后,应当把自己的类逻辑写到findClass()(protected)方法中;</p>
<blockquote>
<p>热部署:OSGI(类加载器精髓);</p>
<p>NB技巧:子类可以公开父类中的protected的方法;</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">findClass_</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.findClass();<span class="comment">//protected</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="静态分派与动态分派"><a href="#静态分派与动态分派" class="headerlink" title="静态分派与动态分派"></a>静态分派与动态分派</h1><p><a id="way6-1"></a>  </p>
<h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Map</span> <span class="built_in">map</span>=<span class="literal">new</span> HashMap();</div></pre></td></tr></table></figure>
<p>Map(静态类型,外观类型接口类型(我习惯叫)):其变化仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的。</p>
<p>HashMap(实际类型):其变化的结果在运行期才可确定，编译器不编译程序时并不知道一个对象的实际类型是什么。</p>
<ul>
<li>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。<ul>
<li>①.静态分派典型的应用是方法重载，</li>
<li>②.静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的 </li>
<li>③.对于方法参数的匹配也是根据变量的静态类型来确定，在很多情况下根据参数的类型并不能找到唯一的方法调用，这个时候的处理方式是找到一个最合适的方法。比如：</li>
</ul>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OverLoad</span> &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">int</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello int"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">long</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello long"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Character arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Character"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Serializable arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Serializable"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Object arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello object"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> ...arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello arg..."</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </div><div class="line">        sayHello(<span class="string">'a'</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从头注解方法，结果会按顺序输出。</p>
<p>1、基本类型是重载按char-&gt;int-&gt;long-&gt;float-&gt;double-&gt;Character-&gt;Serializable(因为Character实现了他)顺序匹配的。</p>
<p>2、可变参数的重载优先级是最低的。</p>
<blockquote>
<p>Tips:如果出现了两个参数分别为Serializable和Comparable(Character实现这两个),编译器无法确定自动转型那种类型。提示类型模糊拒绝编译;</p>
</blockquote>
<p><a id="way6-2"></a>  </p>
<h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>方法执行会找到对应的实际类型。</p>
<p><a id="way7-1"></a>  </p>
<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><blockquote>
<p>NB之处 不仅仅能实现别人的接口,也能实现自己的接口这样相当于 对象本身了,但是可以却可以在方法执行之前或之后搞事情了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;  </div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </div><div class="line">            System.out.println(<span class="string">"hello world"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;  </div><div class="line">        Object originalObj;  </div><div class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span></span>&#123;  </div><div class="line">            <span class="keyword">this</span>.originalObj = originalObj;  </div><div class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass(),  </div><div class="line">                    getInterfaces(),<span class="keyword">this</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></div><div class="line">                <span class="keyword">throws</span> Throwable &#123;  </div><div class="line">            System.out.println(<span class="string">"welcome"</span>);  </div><div class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        <span class="comment">/* 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请生工创建) */</span></div><div class="line">     	System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div><div class="line">        IHello hello = (IHello)<span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());  </div><div class="line">        hello.sayHello();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”)-&gt;设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请生工创建)</p>
</blockquote>
<p>java逆向工具:为了解决把1.5中编写的代码放到1.4 1.3的环境部署使用的问题。比较出色的Retrotranslator</p>
<h1 id="Java魔法糖"><a href="#Java魔法糖" class="headerlink" title="Java魔法糖"></a>Java魔法糖</h1><p><a id="way8-1"></a> </p>
<h2 id="泛型与擦除"><a href="#泛型与擦除" class="headerlink" title="泛型与擦除"></a>泛型与擦除</h2><p>编译后的字节码文件中替换为原生类型,并且在相应的位置插入强制转换;</p>
<blockquote>
<p>所以泛型遇到重载,不会执行编译;例如参数List<integer>和List<string>编译后的文件是一样的所以你懂的;</string></integer></p>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> </span>&#123;</div><div class="line">    <span class="comment">//看bin目录下的编译文件;</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//泛型 自动装箱,自动拆箱,便利循环,变长参数;</span></div><div class="line">        List&lt;Integer&gt; list= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> integer : list) &#123;</div><div class="line">            <span class="keyword">sum</span>+=integer;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">sum</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后文件<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Sugar &#123;</div><div class="line">    <span class="keyword">public</span> Sugar() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line">        List list = Arrays.asList(new <span class="keyword">Integer</span>[]&#123;<span class="keyword">Integer</span>.valueOf(<span class="number">1</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">2</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">3</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">4</span>)&#125;);</div><div class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="built_in">int</span> <span class="keyword">integer</span>;</div><div class="line">        for(Iterator var3 = list.iterator(); var3.hasNext(); <span class="built_in">sum</span> += <span class="keyword">integer</span>) &#123;</div><div class="line">            <span class="keyword">integer</span> = ((<span class="keyword">Integer</span>)var3.next()).intValue();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.<span class="keyword">out</span>.println(<span class="built_in">sum</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/luhaoaimama1/AndroidNote-Zone/blob/master/note/jvm/%E8%AF%AD%E6%B3%95%E7%B3%96/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E9%99%B7%E9%98%B1.java" target="_blank" rel="external">自动装箱陷阱</a></p>
</blockquote>
<h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><p><a id="way9-1"></a> </p>
<h2 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h2><p>当定义为volatile之后具备两种特性:<br>第一保证此变量对<strong>所有线程</strong>的可见性。当一个线程修改了这个值,新值对于其他线程来说立即可知;<br>第二:禁止指令重排序优化;</p>
<blockquote>
<p>这个目录的&lt;<strong>volatile教材</strong>&gt;文件夹有对应的范例;</p>
<p>volatile和普通变量性能几乎没有区别,比synchronized关键字快;</p>
</blockquote>
<p><a id="way9-2"></a> </p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>主要两种:协同式调度和抢占式调度<br>协同(不用):执行时间由线程本身来控制。吧自己工作执行完后主动通知系统切换到另一个线程;</p>
<blockquote>
<p>坏处:如果线程出现堵塞那么所有都堵塞了</p>
</blockquote>
<p>抢占:系统分配时间,切换不由线程本身来决定</p>
<blockquote>
<p>Thread.yield()可以让出执行时间.获取时间则没有办法;</p>
<p>额外知识 ++不是原子性,AtomicInteger CAS(原子性)来避免阻塞同步;</p>
</blockquote>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://www.cnblogs.com/leesf456/p/5218594.html" target="_blank" rel="external">http://www.cnblogs.com/leesf456/p/5218594.html</a></p>

      
    </div>

    
      <footer class="post-footer">
        <div class="post-tags">
          
            <a href="/tags/jvm/">jvm</a>
          
        </div>

        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/12/18/drawText/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Android-drawText()详解</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/11/20/Rebound/">
        <span class="next-text nav-default">Android-Rebound(弹簧系统-让动画不再僵硬)的简单使用与源码分析</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

      </footer>
    
  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/05/JVM/"
           data-title="深入理解Java虚拟机总结" data-url="https://luhaoaimama1.github.io/2016/12/05/JVM/">
      </div>
    
  </div>

        </div>  
      </main>

      <footer id="footer" class="footer">
  <div class="social-links">
    
      
        
          <a href="mailto:1149324777@email.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/luhaoaimama1" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://weibo.com/u/2193119237" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2017

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Zone</span>
  </span>
</div>
      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"luhaoaimama1"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>



    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

    <script type="text/javascript" src="/js/src/even.js?v=2.1.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.1.0"></script>

  </body>
</html>
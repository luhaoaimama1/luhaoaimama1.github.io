<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Rxjava2总结"><link rel="alternate" href="https://luhaoaimama1.github.io/archives/" title="Zone"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://luhaoaimama1.github.io/2017/07/31/rxjava/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6d26901ed1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "sR4k6iKUohMuLBnjFbpeGbKg-gzGzoHsz",
      appKey: "JNC93ECkxxvdiy69B2LJmWy9"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"sR4k6iKUohMuLBnjFbpeGbKg-gzGzoHsz","app_key":"JNC93ECkxxvdiy69B2LJmWy9"},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Rxjava2总结 - Zone</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Zone</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a><a href="/introduce/">
        <li class="mobile-menu-item">项目简介
          </li>
      </a><a href="/friendlinks/">
        <li class="mobile-menu-item">外联
          </li>
      </a><a href="/message/">
        <li class="mobile-menu-item">留言
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Zone</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/introduce/">
            项目简介
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/friendlinks/">
            外联
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/message/">
            留言
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Rxjava2总结
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-07-31
        </span><span class="post-visits" data-url="/2017/07/31/rxjava/" data-title="Rxjava2总结">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rxjava2基础认知"><span class="toc-text">Rxjava2基础认知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础概念"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建操作"><span class="toc-text">创建操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#过滤操作"><span class="toc-text">过滤操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#辅助操作"><span class="toc-text">辅助操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变换操作"><span class="toc-text">变换操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合并操作符"><span class="toc-text">合并操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件操作"><span class="toc-text">条件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#阻塞操作"><span class="toc-text">阻塞操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组合操作"><span class="toc-text">组合操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Subjects"><span class="toc-text">Subjects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Single与Completable"><span class="toc-text">Single与Completable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义操作符"><span class="toc-text">自定义操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实用技巧"><span class="toc-text">实用技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference-amp-Thanks："><span class="toc-text">Reference&amp;Thanks：</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="Rxjava2基础认知"><a href="#Rxjava2基础认知" class="headerlink" title="Rxjava2基础认知"></a>Rxjava2基础认知</h2><ul>
<li><p>形式正确的有限Observable<br>调用观察者的onCompleted正好一次或者它的onError正好一次，而且此后不能再调用观察者的任何其它方法。如果onComplete 或者 onError 走任何一个 都会 主动解除订阅关系；</p>
<ul>
<li>如果解除订阅关系以后在发射 onError 则会 报错;而发射onComplete则不会。</li>
<li>注意解除订阅关系 还是可以发射 onNext</li>
</ul>
</li>
<li><p>Disposable类:</p>
<ul>
<li>dispose():主动解除订阅</li>
<li>isDisposed():查询是否解除订阅 true 代表 已经解除订阅</li>
</ul>
</li>
<li><p>CompositeDisposable类:可以快速解除所有添加的Disposable类<br>每当我们得到一个Disposable时就调用CompositeDisposable.add()将它添加到容器中, 在退出的时候, 调用CompositeDisposable.clear() 即可快速解除.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">CompositeDisposable compositeDisposable=new CompositeDisposable();</span><br><span class="line">Observable.create(new ObservableOnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void subscribe(ObservableEmitter&lt;Integer&gt; emitter) throws Exception &#123;</span><br><span class="line">                emitter.onNext(1);</span><br><span class="line">                emitter.onComplete();或者 emitter.onError(new Throwable(&quot;O__O &quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Observer&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            private Disposable mDisposable;</span><br><span class="line">            @Override</span><br><span class="line">            public void onSubscribe(Disposable d) &#123;</span><br><span class="line">                &lt;!-- 订阅   --&gt;</span><br><span class="line">                mDisposable = d;</span><br><span class="line">                &lt;!-- 添加到容器中 --&gt;</span><br><span class="line">                compositeDisposable.add(d);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onNext(Integer value) &#123;</span><br><span class="line">                &lt;!-- 判断mDisposable.isDisposed() 如果解除了则不需要处理 --&gt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onError(Throwable e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onComplete() &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &lt;!-- 解除所有订阅者 --&gt;</span><br><span class="line">        compositeDisposable.clear();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>Scheduler scheduler</li>
</ul>
<blockquote>
<p>timer() alt+点击timer可查看 关于timer的方法 可以看到时候有这个参数的变体!</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gy1fhyjg4qv2fj30v204ot9a.jpg" alt></p>
<ul>
<li>Callable<u> bufferSupplier:自定义装载的容器</u></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(1, 10)</span><br><span class="line">           //() -&gt; new ArrayList&lt;&gt;() 则是bufferSupplier</span><br><span class="line">           .buffer(2, 1,() -&gt; new ArrayList&lt;&gt;())</span><br><span class="line">           .subscribe(integers -&gt; System.out.println(integers));</span><br></pre></td></tr></table></figure>

<h2 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h2><ul>
<li>create : 创建一个具有发射能力的Observable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(e -&gt; &#123;</span><br><span class="line">    e.onNext(&quot;Love&quot;);</span><br><span class="line">    e.onNext(&quot;For&quot;);</span><br><span class="line">    e.onNext(&quot;You!&quot;);</span><br><span class="line">    e.onComplete();</span><br><span class="line">&#125;).subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>just:只是简单的原样发射,可将数组或Iterable当做单个数据。它接受一至九个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;Love&quot;, &quot;For&quot;, &quot;You!&quot;)</span><br><span class="line">                .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>empty:创建一个不发射任何数据但是正常终止的Observable</li>
<li>never:创建一个不发射数据也不终止的Observable</li>
<li>error:创建一个不发射数据以一个错误终止的Observable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty();</span><br><span class="line">Observable.never();</span><br><span class="line">Observable.error(new Throwable(&quot;O__O&quot;))</span><br></pre></td></tr></table></figure>

<ul>
<li>timer 在延迟一段给定的时间后发射一个简单的数字0</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.timer(1000, TimeUnit.MILLISECONDS)</span><br><span class="line">              .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>range:<ul>
<li>start:起始值</li>
<li>count:一个是范 围的数据的数目。0不发送 ，负数 异常</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(5, 3)</span><br><span class="line">        //输出 5,6,7</span><br><span class="line">        .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>intervalRange<ul>
<li>start,count:同range</li>
<li>initialDelay 发送第一个值的延迟时间</li>
<li>period  每两个发射物的间隔时间</li>
<li>unit,scheduler 额你懂的</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.intervalRange(5, 100, 3000, 100,</span><br><span class="line">                TimeUnit.MILLISECONDS, Schedulers.io())</span><br><span class="line">                .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>interval:相当于intervalRange的start=0；<blockquote>
<p>period 这个值一旦设定后是不可变化的</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//period 以后的美每次间隔 这个值一旦设定后是不可变化的  所以 count方法无效的！</span><br><span class="line">int[] s = new int[]&#123;0&#125;;</span><br><span class="line"> Observable.interval(3000, 100 + count(s), TimeUnit.MILLISECONDS, Schedulers.io())</span><br><span class="line">         .subscribe(s2 -&gt; System.out.println(s2));</span><br><span class="line"></span><br><span class="line"> private int count(int[] s) &#123;</span><br><span class="line">         int result = s[0] * 1000;</span><br><span class="line">         s[0] = s[0] + 1;</span><br><span class="line">         return result;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>defer 直到有观察者订阅时才创建Observable，并且为每个观察者创建一个新的Observable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.defer(() -&gt; Observable.just(&quot;Love&quot;, &quot;For&quot;, &quot;You!&quot;))</span><br><span class="line">              .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>from系列</p>
<ul>
<li><p>fromArray</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] items = &#123;0, 1, 2, 3, 4, 5&#125;;</span><br><span class="line">       Observable.fromArray(items).subscribe(</span><br><span class="line">               integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>fromCallable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromCallable(() -&gt; Arrays.asList(&quot;hello&quot;, &quot;gaga&quot;))</span><br><span class="line">                .subscribe(strings -&gt; System.out.println(strings))</span><br></pre></td></tr></table></figure>
</li>
<li><p>fromIterable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(Arrays.&lt;String&gt;asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;))</span><br><span class="line">             .subscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>fromFuture</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromFuture(Observable.just(1).toFuture())</span><br><span class="line">               .doOnComplete(() -&gt; System.out.println(&quot;complete&quot;))</span><br><span class="line">               .subscribe();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><ul>
<li>elementAt:只发射第N项数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 无默认值版本 --&gt;</span><br><span class="line"> Observable.just(1,2)</span><br><span class="line">            .elementAt(0)</span><br><span class="line">            .subscribe(o -&gt; System.out.print(o ));//结果:1</span><br><span class="line"></span><br><span class="line">&lt;!-- 带默认值的变体版本 --&gt;</span><br><span class="line">Observable.range(0, 10)</span><br><span class="line">//        如果索引值大于数据 项数，它会发射一个默认值(通过额外的参数指定)，而不是抛出异常。</span><br><span class="line">//    但是如果你传递一 个负数索引值，它仍然会抛出一个 IndexOutOfBoundsException 异常。</span><br><span class="line">                .elementAt(100, -100)</span><br><span class="line">                .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>IgnoreElements:如果你不关心一个Observable发射的数据，但是希望在它完成时或遇到错误终止时收到通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 10)</span><br><span class="line">               .ignoreElements()</span><br><span class="line">               .subscribe(() -&gt; System.out.println(&quot;complete&quot;)</span><br><span class="line">                       , throwable -&gt; System.out.println(&quot;throwable&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>take系列</p>
<ul>
<li><p>变体 count系列:只发射前面的N项数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">               .take(3)</span><br><span class="line">               .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 time系列: 发射Observable开始的那段时间发射 的数据，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">          .take(100, TimeUnit.MILLISECONDS)</span><br><span class="line">          .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>takeLast</p>
<ul>
<li><p>变体 count系列:只发射后面的N项数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">                    .takeLast(3)</span><br><span class="line">                    .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 time系列: 发射在原始Observable的生命周 期内最后一段时间内发射的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">               .takeLast(100, TimeUnit.MILLISECONDS)</span><br><span class="line">               .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>takeUntil:发送complete的结束条件 当然发送结束之前也会包括这个值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(2,3,4,5)</span><br><span class="line">        //发送complete的结束条件 当然发送结束之前也会包括这个值</span><br><span class="line">        .takeUntil(integer -&gt;  integer&gt;3)</span><br><span class="line">        .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));//2,3,4</span><br></pre></td></tr></table></figure>

<ul>
<li>takeWhile:当不满足这个条件 会发送结束 不会包括这个值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(2,3,4,5)</span><br><span class="line">        //当不满足这个条件 会发送结束 不会包括这个值</span><br><span class="line">        .takeWhile(integer -&gt;integer&lt;=4 )</span><br><span class="line">        .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));//2,3,4</span><br></pre></td></tr></table></figure>

<ul>
<li><p>skip系列</p>
<ul>
<li><p>变体 count系列:丢弃Observable发射的前N项数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,5)</span><br><span class="line">               .skip(3)</span><br><span class="line">               .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 time系列:丢弃原始Observable开始的那段时间发 射的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,5)</span><br><span class="line">               .skip(3)</span><br><span class="line">               .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>skipLast</p>
<ul>
<li><p>变体 count系列:丢弃Observable发射的前N项数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,5)</span><br><span class="line">               .skipLast(3)</span><br><span class="line">               .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 time系列:丢弃在原始Observable的生命周 期内最后一段时间内发射的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0,10)</span><br><span class="line">             .skipLast(100, TimeUnit.MILLISECONDS)</span><br><span class="line">             .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>distinct:去重</p>
<ul>
<li><p>keySelector:这个函数根据原始Observable发射的数据项产生一个 Key，然后，比较这些Key而不是数据本身，来判定两个数据是否是不同的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Observable.just(1, 2, 1, 2, 3)</span><br><span class="line">            //这个函数根据原始Observable发射的数据项产生一个 Key，</span><br><span class="line">            // 然后，比较这些Key而不是数据本身，来判定两个数据是否是不同的</span><br><span class="line">            .distinct(integer -&gt; Math.random())</span><br><span class="line">            .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br><span class="line">日志:</span><br><span class="line">原因 key不同 所以当做数据不同处理</span><br><span class="line">1	2	1	2	3</span><br></pre></td></tr></table></figure>
</li>
<li><p>无参版本 就是内部实现了的keySelector通过生成的key就是value本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 1, 2, 3)</span><br><span class="line">             .distinct()</span><br><span class="line">             .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br><span class="line"> 日志:</span><br><span class="line"> 1	2	3</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>distinctUntilChanged(相邻去重):它只判定一个数据和它的直接前驱是 否是不同的。</p>
<blockquote>
<p>其他概念与distinct一样</p>
</blockquote>
</li>
<li><p>throttleWithTimeout/debounce:</p>
</li>
</ul>
<blockquote>
<p>操作符会过滤掉发射速率过快的数据项<br>throttleWithTimeout/debounce： 含义相同<br>如果发送数据后 指定时间段内没有新数据的话 。则发送这条<br>如果有新数据 则以这个新数据作为将要发送的数据项，并且重置这个时间段，重新计时。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    Observable.create(e -&gt; &#123;</span><br><span class="line">            e.onNext(&quot;onNext 0&quot;);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            e.onNext(&quot;onNext 1&quot;);</span><br><span class="line">            Thread.sleep(230);</span><br><span class="line">            e.onNext(&quot;onNext 2&quot;);</span><br><span class="line">            Thread.sleep(300);</span><br><span class="line">            e.onNext(&quot;onNext 3&quot;);</span><br><span class="line">            Thread.sleep(400);</span><br><span class="line">            e.onNext(&quot;onNext 4&quot;);</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">            e.onNext(&quot;onNext 5&quot;);</span><br><span class="line">            e.onNext(&quot;onNext 6&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">                .debounce(330, TimeUnit.MILLISECONDS)</span><br><span class="line">//                .throttleWithTimeout(330, TimeUnit.MILLISECONDS)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(o -&gt; System.out.println(o));//结果 3 4 6</span><br></pre></td></tr></table></figure>

<ul>
<li><p>filter:只发射通过了谓词测试的数据项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 10)</span><br><span class="line">        //过滤掉false的元素</span><br><span class="line">        .filter(integer -&gt; integer % 2 == 0)</span><br><span class="line">        .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>ofType:ofType 是 filter 操作符的一个特殊形式。它过滤一个Observable只返回指定类型的数据</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(0, &quot;what?&quot;, 1, &quot;String&quot;, 3)</span><br><span class="line">             //ofType 是 filter 操作符的一个特殊形式。它过滤一个Observable只返回指定类型的数据。</span><br><span class="line">             .ofType(String.class)</span><br><span class="line">             .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>first:只发射第一项(或者满足某个条件的第一项)数 感觉和take(1)  elementAt(0)差不多</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 10)</span><br><span class="line">          //如果元数据没有发送  则有发送默认值</span><br><span class="line">          .first(-1)</span><br><span class="line">          .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>last:只发射最后一项(或者满足某个条件的最后一项)数据 感觉和takeLast(1)差不多</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">              //如果元数据没有发送  则有发送默认值</span><br><span class="line">              .last(-1)</span><br><span class="line">              .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>sample/throttleLast: 周期采样后 发送最后的数据</li>
<li>throttleFirst:周期采样 的第一条数据 发送<blockquote>
<p>注意: 如果是已经被发送过的 则不会继续发送</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> Observable.create(e -&gt; &#123;</span><br><span class="line">            e.onNext(&quot;onNext 0&quot;);</span><br><span class="line">            Thread.sleep(100);</span><br><span class="line">            e.onNext(&quot;onNext 1&quot;);</span><br><span class="line">            Thread.sleep(50);</span><br><span class="line">            e.onNext(&quot;onNext 2&quot;);</span><br><span class="line">            Thread.sleep(70);</span><br><span class="line">            e.onNext(&quot;onNext 3&quot;);</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            e.onNext(&quot;onNext 4&quot;);</span><br><span class="line">            e.onNext(&quot;onNext 5&quot;);</span><br><span class="line">        &#125;)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                &lt;!--  结果 : onNext 2	onNext 3	onNext 5	--&gt;</span><br><span class="line">                .sample(200, TimeUnit.MILLISECONDS,Schedulers.newThread())</span><br><span class="line">                &lt;!--  结果 : onNext 2	onNext 3	onNext 5	--&gt;</span><br><span class="line">//                .throttleLast(200, TimeUnit.MILLISECONDS,Schedulers.newThread())</span><br><span class="line">                &lt;!--  结果 : onNext 0	onNext 3	onNext 4	--&gt;</span><br><span class="line">//                .throttleFirst(200, TimeUnit.MILLISECONDS,Schedulers.newThread())</span><br><span class="line">                .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<h2 id="辅助操作"><a href="#辅助操作" class="headerlink" title="辅助操作"></a>辅助操作</h2><ul>
<li>repeat:不是创建一个Observable,而是重复发射原始,Observable的数据序列，这个序列或者是无限的，或者通过 repeat(n) 指定重复次数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;Love&quot;, &quot;For&quot;, &quot;You!&quot;)</span><br><span class="line">          .repeat(3)//重复三次</span><br><span class="line">          .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>repeatUntil:getAsBoolean 如果返回 true则不repeat false则repeat.主要用于动态控制</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(&quot;Love&quot;, &quot;For&quot;, &quot;You!&quot;)</span><br><span class="line">                .repeatUntil(new BooleanSupplier() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean getAsBoolean() throws Exception &#123;</span><br><span class="line">                        System.out.println(&quot;getAsBoolean&quot;);</span><br><span class="line">                        count++;</span><br><span class="line">                        if (count == 3)</span><br><span class="line">                            return true;</span><br><span class="line">                        else</span><br><span class="line">                            return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>delay:延迟一段指定的时间再发射来自Observable的发射物<blockquote>
<p>注意：<br>delay 不会平移 onError 通知，它会立即将这个通知传递给订阅者，同时丢弃任何待 发射的 onNext 通知。<br>然而它会平移一个 onCompleted 通知</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">          .delay(1400, TimeUnit.MILLISECONDS)</span><br><span class="line">          .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>delaySubscription:让你你可以延迟订阅原始Observable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1)</span><br><span class="line">                .delaySubscription(2000, TimeUnit.MILLISECONDS)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt;complete&quot;)</span><br><span class="line">                        , disposable -&gt; System.out.println(&quot;===&gt;订阅&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>do系列</p>
<ul>
<li><p>doOnEach:注册一个回调，它产生的Observable每发射一项数据就会调用它一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">              .doOnEach(integerNotification -&gt; System.out.println(integerNotification.getValue()))</span><br><span class="line">              .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">  日志:</span><br><span class="line">  doOnEach:</span><br><span class="line">  doOnEach:0===&gt;0</span><br><span class="line">  doOnEach:1===&gt;1</span><br><span class="line">  doOnEach:2===&gt;2</span><br><span class="line">  doOnEach:null</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnNext:注类似doOnEach 不是接受一个 Notification 参数，而是接受发射的数据项。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> Observable.range(0, 3)</span><br><span class="line">         .doOnNext(integer -&gt; &#123;</span><br><span class="line">             if (integer == 2)</span><br><span class="line">                 throw new Error(&quot;O__O&quot;);</span><br><span class="line">             System.out.print(integer);</span><br><span class="line">         &#125;)</span><br><span class="line">         .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                 , throwable -&gt; System.out.print(&quot;===&gt;throwable&quot;)</span><br><span class="line">                 , () -&gt; System.out.print(&quot;===&gt;complete&quot;));</span><br><span class="line">日志:</span><br><span class="line">0===&gt;0	1===&gt;1	===&gt;throwable</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnSubscribe:注册一个动作，在观察者订阅时使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">              .doOnSubscribe(disposable -&gt; System.out.print(&quot;开始订阅&quot;))</span><br><span class="line">              .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">    日志:</span><br><span class="line">     开始订阅===&gt;0	===&gt;1	===&gt;2</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnComplete:注册一个动作，在观察者OnComplete时使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">               .doOnComplete(() -&gt; System.out.print(&quot;doOnComplete&quot;))</span><br><span class="line">               .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">   日志:</span><br><span class="line">    ===&gt;0	===&gt;1	===&gt;2	doOnComplete</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnError:注册一个动作，在观察者doOnError时使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.error(new Throwable(&quot;?&quot;))</span><br><span class="line">               .doOnError(throwable -&gt; System.out.print(&quot;throwable&quot;))</span><br><span class="line">               .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">  日志:</span><br><span class="line">  异常信息....</span><br><span class="line">  throwable</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnTerminate:注册一个动作，Observable终止之前会被调用，无论是正 常还是异常终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Observable.range(0, 3)</span><br><span class="line">         .doOnTerminate(() -&gt; System.out.print(&quot;\t doOnTerminate&quot;))</span><br><span class="line">         .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">日志:</span><br><span class="line">===&gt;0	===&gt;1	===&gt;2		 doOnTerminate</span><br></pre></td></tr></table></figure>
</li>
<li><p>doFinally:注册一个动作,当它产生的Observable终止之后会被调用，无论是正常还 是异常终止。在doOnTerminate之后执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">                .doFinally(() -&gt; System.out.print(&quot;\t doFinally&quot;))</span><br><span class="line">                .doOnTerminate(() -&gt; System.out.print(&quot;\t  doOnTerminate&quot;))</span><br><span class="line">                .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line"> 日志:</span><br><span class="line"> ===&gt;0	===&gt;1	===&gt;2		  doOnTerminate	 doFinally</span><br></pre></td></tr></table></figure>
</li>
<li><p>doOnDispose:注册一个动作,当【观察者取消】订阅它生成的Observable它就会被调</p>
<blockquote>
<p>注意:貌似需要在 为出现complete和error的时候 dispose才会触发 ~</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Disposable ab = Observable.interval(1, TimeUnit.SECONDS)</span><br><span class="line">              .take(3)</span><br><span class="line">              .doOnDispose(() -&gt; System.out.println(&quot;解除订阅&quot;))</span><br><span class="line">              .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">      ab.dispose();</span><br><span class="line">日志:</span><br><span class="line">解除订阅</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>materialize:将数据项和事件通知都当做数据项发射</p>
</li>
<li><p>dematerialize:materialize相反</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">                //将Observable转换成一个通知列表。</span><br><span class="line">                .materialize()</span><br><span class="line">                //与上面的作用相反，将通知逆转回一个Observable</span><br><span class="line">                .dematerialize()</span><br><span class="line">                .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>observeOn:指定一个观察者在哪个调度器上观察这个Observable</li>
<li>subscribeOn:指定Observable自身在哪个调度器上执行</li>
</ul>
<blockquote>
<p>注意 遇到错误 会立即处理而不是等待下游还没观察的数据<br>既onError 通知会跳到(并吞掉)原始Observable发射的数据项前面</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">              .subscribeOn(Schedulers.newThread())</span><br><span class="line">              .observeOn(Schedulers.newThread())</span><br><span class="line">              .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>subscribe:操作来自Observable的发射物和通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Javadoc: subscribe()</span><br><span class="line">Javadoc: subscribe(onNext)</span><br><span class="line">Javadoc: subscribe(onNext,onError)</span><br><span class="line">Javadoc: subscribe(onNext,onError,onComplete)</span><br><span class="line">Javadoc: subscribe(onNext,onError,onComplete,onSubscribe)</span><br><span class="line">Javadoc: subscribe(Observer)</span><br><span class="line">Javadoc: subscribe(Subscriber)</span><br></pre></td></tr></table></figure>
</li>
<li><p>foreach:forEach 方法是简化版的 subscribe ，你同样可以传递一到三个函数给它，解释和传递给 subscribe 时一样</p>
</li>
</ul>
<blockquote>
<p>不同的是，你无法使用 forEach 返回的对象取消订阅。也没办法传递一个可以用于取消订阅 的参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">        //subscribe的简化版本  没啥用</span><br><span class="line">        .forEach(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>serialize:保证上游下游同一线程 ，防止不同线程下 onError 通知会跳到(并吞掉)原始Observable发射的数据项前面的错误行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 3)</span><br><span class="line">           .serialize()</span><br><span class="line">           .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>
</li>
<li><p>Timestamp:它将一个发射T类型数据的Observable转换为一个发射类型 为Timestamped<t> 的数据的Observable，每一项都包含数据的原始发射时间</t></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">               .take(3)</span><br><span class="line">                .timestamp()</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt; throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt; complete&quot;)</span><br><span class="line">                        , disposable -&gt; System.out.println(&quot;===&gt; 订阅&quot;));</span><br><span class="line">    日志:</span><br><span class="line">    ===&gt; 订阅</span><br><span class="line">    ===&gt;Timed[time=1501224256554, unit=MILLISECONDS, value=0]</span><br><span class="line">    ===&gt;Timed[time=1501224256651, unit=MILLISECONDS, value=1]</span><br><span class="line">    ===&gt;Timed[time=1501224256751, unit=MILLISECONDS, value=2]</span><br><span class="line">    ===&gt; complete</span><br></pre></td></tr></table></figure>
</li>
<li><p>timeInterval:一个发射数据的Observable转换为发射那些数据发射时间间隔的Observable</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">//         把发送的数据 转化为  相邻发送数据的时间间隔实体</span><br><span class="line">                .timeInterval()</span><br><span class="line">//                .timeInterval(Schedulers.newThread())</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt;complete&quot;)</span><br><span class="line">                        , disposable -&gt; System.out.println(&quot;===&gt;订阅&quot;));</span><br><span class="line">    日志:</span><br><span class="line">    ===&gt;订阅</span><br><span class="line">    ===&gt;Timed[time=113, unit=MILLISECONDS, value=0]</span><br><span class="line">    ===&gt;Timed[time=102, unit=MILLISECONDS, value=1]</span><br><span class="line">    ===&gt;Timed[time=97, unit=MILLISECONDS, value=2]</span><br><span class="line">    ===&gt;complete</span><br></pre></td></tr></table></figure>

<ul>
<li><p>timeout</p>
<ul>
<li><p>变体:过了一个指定的时长仍没有发射数据(不是仅仅考虑第一个)，它会发一个错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">//        过了一个指定的时长仍没有发射数据(不是仅仅考虑第一个)，它会发一个错误</span><br><span class="line">                .timeout(50, TimeUnit.MILLISECONDS)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt;timeout throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt;timeout complete&quot;)</span><br><span class="line">                        , disposable -&gt; System.out.println(&quot;===&gt;timeout 订阅&quot;));</span><br><span class="line">timeout:</span><br><span class="line">===&gt;timeout 订阅</span><br><span class="line">===&gt;timeout throwable</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 备用Observable:过了一个指定的时长仍没有发射数据(不是仅仅考虑第一个)，它会发一个错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Observable&lt;Integer&gt; other;</span><br><span class="line"> Observable.empty()</span><br><span class="line">         // 过了一个指定的时长仍没有发射数据(不是仅仅考虑第一个)，他会用备用Observable 发送数据，本身的会发送一个compelte</span><br><span class="line">         .timeout(50, TimeUnit.MILLISECONDS, other = Observable.just(2, 3, 4))</span><br><span class="line">         .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                 , throwable -&gt; System.out.println(&quot;===&gt;timeout2 throwable&quot;)</span><br><span class="line">                 , () -&gt; System.out.println(&quot;===&gt;timeout2 complete&quot;)</span><br><span class="line">                 , disposable -&gt; System.out.println(&quot;===&gt;timeout2 订阅&quot;));</span><br><span class="line"> other.subscribe(o -&gt; System.out.println(&quot;k ===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">timeout2:</span><br><span class="line">===&gt;timeout2 订阅</span><br><span class="line">===&gt;timeout2 complete</span><br><span class="line">k ===&gt;2</span><br><span class="line">k ===&gt;3</span><br><span class="line">k ===&gt;4</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="变换操作"><a href="#变换操作" class="headerlink" title="变换操作"></a>变换操作</h2><ul>
<li>map:对Observable发射的每一项数据应用一个函数，执行变换操作,就是方形过渡到圆形</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2)</span><br><span class="line">              .map(integer -&gt; &quot;This is result &quot; + integer)</span><br><span class="line">              .subscribe(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<ul>
<li>flatMap: 将一个发射数据的Observable变换为多个Observables，然后将它们发射的数据合并后放进一个单独的Observable<ul>
<li>mapper:根据发射数据映射成Observable</li>
<li>combiner: 用来合并 的</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意:FlatMap 对这些Observables发射的数据做的是合并( merge )操作，因此它们可能是交 错的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">     Observable.just(1, 2, 3)</span><br><span class="line">               .flatMap(integer -&gt; Observable.range(integer * 10, 2)</span><br><span class="line">                       , (a, b) -&gt; &#123;</span><br><span class="line">                           //a ： 原始数据的 just(1,2,3) 中的值</span><br><span class="line">                           //b ： 代表 flatMap后合并发送的数据的值</span><br><span class="line">                           System.out.print(&quot;\n a:&quot; + a + &quot;\t b:&quot; + b);</span><br><span class="line">                           //return flatMap发送的值 ，经过处理后 而发送的值</span><br><span class="line">                           return a + b;</span><br><span class="line">                       &#125;)</span><br><span class="line">               .subscribe(s -&gt; System.out.print(&quot;\t&quot;+s));</span><br><span class="line">日志：</span><br><span class="line"> &lt;!-- 这里有顺序是因为没有在其他线程执行 --&gt;</span><br><span class="line">a:1	 b:10	11</span><br><span class="line">a:1	 b:11	12</span><br><span class="line">a:2	 b:20	22</span><br><span class="line">a:2	 b:21	23</span><br><span class="line">a:3	 b:30	33</span><br><span class="line">a:3	 b:31	34</span><br></pre></td></tr></table></figure>

<ul>
<li>concatMap:类似FlatMap但是保证顺序 因为没有合并操作！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">            .concatMap(integer -&gt; Observable.range(integer * 10, 2))</span><br><span class="line">            .subscribe(s -&gt; System.out.print(&quot;\t&quot;+s));</span><br></pre></td></tr></table></figure>

<ul>
<li>cast:在发射之前强制将Observable发射的所有数据转换为指定类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, &quot;string&quot;)</span><br><span class="line">               .cast(Integer.class)//订阅之后才能发横强转</span><br><span class="line">               .subscribe(integer -&gt; System.out.println(integer)</span><br><span class="line">                       , throwable -&gt; System.out.println(throwable.getMessage()));</span><br></pre></td></tr></table></figure>

<ul>
<li>groupBy:通过keySelector的apply的值当做key 进行分组,发射GroupedObservable(有getKey()方法)的group 通过group继续订阅取得其组内的值;<ul>
<li>keySelector:通过这个的返回值 当做key进行分组</li>
<li>valueSelector:value转换</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Observable.range(0, 10)</span><br><span class="line">                .groupBy(integer -&gt; integer % 2, integer -&gt; &quot;(&quot; + integer + &quot;)&quot;)</span><br><span class="line">                .subscribe(group -&gt; &#123;</span><br><span class="line">                    group.subscribe(integer -&gt; System.out.println(</span><br><span class="line">                            &quot;key:&quot; + group.getKey() + &quot;==&gt;value:&quot; + integer));</span><br><span class="line">                &#125;);</span><br><span class="line">日志：</span><br><span class="line">key:0==&gt;value:(0)</span><br><span class="line">key:1==&gt;value:(1)</span><br><span class="line">key:0==&gt;value:(2)</span><br><span class="line">key:1==&gt;value:(3)</span><br><span class="line">key:0==&gt;value:(4)</span><br><span class="line">key:1==&gt;value:(5)</span><br><span class="line">key:0==&gt;value:(6)</span><br><span class="line">key:1==&gt;value:(7)</span><br><span class="line">key:0==&gt;value:(8)</span><br><span class="line">key:1==&gt;value:(9)</span><br></pre></td></tr></table></figure>

<ul>
<li>window: 依照此范例 每三秒收集,Observable在此时间内发送的值。组装成Observable发送出去。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1, TimeUnit.SECONDS).take(7)</span><br><span class="line">                //返回值  Observable&lt;Observable&lt;T&gt;&gt; 即代表 发送Observable&lt;T&gt;</span><br><span class="line">                .window(3, TimeUnit.SECONDS)</span><br><span class="line">                .subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(Schedulers.io())</span><br><span class="line">                .subscribe(integerObservable -&gt; &#123;</span><br><span class="line">                    System.out.println(integerObservable);</span><br><span class="line">                    integerObservable.subscribe(integer -&gt; System.out.println(integerObservable+&quot;===&gt;&quot;+integer));</span><br><span class="line">                &#125;);</span><br><span class="line">日志:</span><br><span class="line">为什么不是 345一起？ 因为会有太细微的时间差。例如5如果在多线程切换的时候是超过3秒的1毫秒则就尴尬了~</span><br><span class="line">io.reactivex.subjects.UnicastSubject@531c3d1c</span><br><span class="line">io.reactivex.subjects.UnicastSubject@531c3d1c===&gt;0</span><br><span class="line">io.reactivex.subjects.UnicastSubject@531c3d1c===&gt;1</span><br><span class="line">io.reactivex.subjects.UnicastSubject@531c3d1c===&gt;2</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2ea0f969</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2ea0f969===&gt;3</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2ea0f969===&gt;4</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2d30de03</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2d30de03===&gt;5</span><br><span class="line">io.reactivex.subjects.UnicastSubject@2d30de03===&gt;6</span><br></pre></td></tr></table></figure>

<ul>
<li>scan:连续地对数据序列的每一项应用一个函数，然后连续发射结果</li>
</ul>
<blockquote>
<p>感觉就是发送一个有 累加(函数) 过程序列<br>    * initialValue（可选） 其实就是放到 原始数据之前发射。<br>    * a 原始数据的中的值<br>    * b 则是最后应用scan函数后发送的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(1, 4, 2)</span><br><span class="line">                //7是用来 对于第一次的 a的值</span><br><span class="line">                .scan(7, (a, b) -&gt; &#123;</span><br><span class="line">                    //b 原始数据的 just(1,4,2) 中的值</span><br><span class="line">                    //a 则是最后应用scan 发送的值</span><br><span class="line">                    System.out.format(&quot;a:%d * b:%d\n&quot;, a, b);</span><br><span class="line">                    return a * b;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(&quot;===&gt;：&quot;+integer));</span><br><span class="line">日志：</span><br><span class="line">===&gt;：7</span><br><span class="line">a:7 * b:1</span><br><span class="line">===&gt;：7</span><br><span class="line">a:7 * b:4</span><br><span class="line">===&gt;：28</span><br><span class="line">a:28 * b:2</span><br><span class="line">===&gt;：56</span><br></pre></td></tr></table></figure>

<ul>
<li><p>buffer系列</p>
<ul>
<li><p>变体 count系列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 范例:发射[1-10]</span><br><span class="line">* buffer count 2 skip 1,结果 [1,2]  [2,3] [3,4] 3=2*1+1</span><br><span class="line">* buffer count 2 skip 2,结果 [1,2]  [3,4] [5,6] 5=2*2+1</span><br><span class="line">* buffer count 2 skip 3,结果 [1,2]  [4,5] [7,8] 7=2*3+1;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>count:缓存的数量</p>
</li>
<li><p>skip:每个缓存创建的间隔数量</p>
<blockquote>
<p>则代表 每次初始偏移量 每次真正的起始值=fistValue+skip*skipCount;<br>注意skip不能小于0<br>可以小于count这样就会导致每个发送的list之间的值会有重复<br>可以大于count这样就会导致每个发送的list之间的值和原有的值之间会有遗漏<br>可以等于count就你懂的了</p>
</blockquote>
</li>
<li><p>bufferSupplier:自定义缓存装载的容器；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(1, 10)</span><br><span class="line">        .buffer(2, 1,() -&gt; new ArrayList&lt;&gt;())//有默认的装载器</span><br><span class="line">        &lt;!-- 其他方法 --&gt;</span><br><span class="line">        &lt;!-- .buffer(2)//skip 默认和count一样 --&gt;</span><br><span class="line">        &lt;!--  .buffer(2, () -&gt; new ArrayList&lt;&gt;())--&gt;</span><br><span class="line">        .subscribe(integers -&gt; System.out.println(integers));</span><br><span class="line"></span><br><span class="line"> 解析:每发射1个。创建一个发射物list buffer,每个buffer缓存2个,收集的存入list后发送。</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体 time系列</p>
<ul>
<li>timespan:缓存的时间</li>
<li>timeskip:每个缓存创建的间隔时间  同skip 可以小于大于等于timespan</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Observable.interval(500, TimeUnit.MILLISECONDS).take(7)</span><br><span class="line">                .buffer(3, 2, TimeUnit.SECONDS, Schedulers.single(),</span><br><span class="line">                        Functions.createArrayList(16))</span><br><span class="line">                .subscribe(integers -&gt; System.out.println(integers));</span><br><span class="line"></span><br><span class="line">解析:每两秒创建一个发射物list buffer,每个buffer缓存三秒 收集的存入list后发送。</span><br><span class="line">日志:</span><br><span class="line">  [0, 1, 2, 3, 4]</span><br><span class="line">  [4, 5, 6]</span><br></pre></td></tr></table></figure>

<ul>
<li>变体 自定义buffer创建和收集时间</li>
<li>bufferOpenings:每当 bufferOpenings 发射了一个数据时，它就 创建一个新的 List,开始装入之后的发射数据</li>
<li>closingSelector:每当 closingSelector 发射了一个数据时,就结束装填数据 发射List。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!-- 范例和time系列的就一样了 --&gt;</span><br><span class="line"> Consumer&lt;Long&gt; longConsumer = aLong -&gt; System.out.println(&quot;开始创建 bufferSupplier&quot;);</span><br><span class="line">        Consumer&lt;Long&gt; longConsumer2 = aLong -&gt; System.out.println(&quot;结束收集&quot;);</span><br><span class="line">        Observable.interval(500, TimeUnit.MILLISECONDS).take(7)</span><br><span class="line">//                .doOnNext(aLong -&gt; System.out.println(&quot;原始发射物：&quot; + aLong))</span><br><span class="line">                .buffer(Observable.interval(2, TimeUnit.SECONDS)</span><br><span class="line">                                .startWith(-1L)//为了刚开始就发射一次</span><br><span class="line">                                .take(2)//多余的我就不创建了</span><br><span class="line">                                .doOnNext(longConsumer)</span><br><span class="line">                        , aLong -&gt; Observable.timer(3, TimeUnit.SECONDS)</span><br><span class="line">                                .doOnNext(longConsumer2)</span><br><span class="line">                        , () -&gt; new ArrayList&lt;&gt;())</span><br><span class="line">                .subscribe(integers -&gt; System.out.println(&quot;buffer发射物&quot; + integers));</span><br><span class="line"></span><br><span class="line">日志:</span><br><span class="line">openings:</span><br><span class="line">开始创建 bufferSupplier</span><br><span class="line">开始创建 bufferSupplier</span><br><span class="line">结束收集</span><br><span class="line">buffer发射物[0, 1, 2, 3, 4]</span><br><span class="line">buffer发射物[4, 5, 6]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>变体 仅仅bufer创建时间</p>
<ul>
<li>boundarySupplier 因为发送一个值代表上个缓存的发送 和这个缓存的创建</li>
</ul>
<blockquote>
<p>这个缓存是连续的, 因为发送一个值代表上个缓存的发送 和这个缓存的创建<br>有发射物的时候 没缓存就创建了 就是 默认第一个发射物的时候由内部创建<br>注意 如果不发送事件缓存 存满了 会自动发送出去的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(500, TimeUnit.MILLISECONDS).take(7)</span><br><span class="line">                .buffer(() -&gt; Observable.timer(2, TimeUnit.SECONDS)</span><br><span class="line">                                .doOnNext(aLong -&gt; System.out.println(&quot;开始创建 bufferSupplier&quot;))</span><br><span class="line">                        , () -&gt; new ArrayList&lt;Object&gt;())</span><br><span class="line">                .subscribe(integers -&gt; System.out.println(integers));</span><br><span class="line">日志:</span><br><span class="line">开始创建 bufferSupplier</span><br><span class="line">[0, 1, 2]</span><br><span class="line">[3, 4, 5, 6]</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="合并操作符"><a href="#合并操作符" class="headerlink" title="合并操作符"></a>合并操作符</h2><ul>
<li>zip(静态方法):只有当原始的Observable中的每一个都发射了 一条数据时 zip 才发射数据。接受一到九个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Long&gt; observable1 = Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">                .subscribeOn(Schedulers.newThread());</span><br><span class="line">        Observable&lt;Long&gt; observable2 = Observable.interval(200, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(4)</span><br><span class="line">                .subscribeOn(Schedulers.newThread());</span><br><span class="line">        Observable.zip(observable1, observable2, (aLong, aLong2) -&gt; &#123;</span><br><span class="line">            System.out.print(&quot;aLong:&quot; + aLong + &quot;\t aLong2:&quot; + aLong2+&quot;\t&quot;);</span><br><span class="line">            return aLong + aLong2;</span><br><span class="line">        &#125;).subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">日志:</span><br><span class="line">aLong:0	 aLong2:0===&gt;0</span><br><span class="line">aLong:1	 aLong2:1===&gt;2</span><br><span class="line">aLong:2	 aLong2:2===&gt;4</span><br></pre></td></tr></table></figure>

<ul>
<li>zipWith:zip的非静态写法,总是接受两个参数，第一个参数是一个Observable或者一个Iterable。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">observable1.zipWith( observable2, (aLong, aLong2) -&gt; &#123;</span><br><span class="line">    System.out.print(&quot;aLong:&quot; + aLong + &quot;\t aLong2:&quot; + aLong2+&quot;\t&quot;);</span><br><span class="line">    return aLong + aLong2;</span><br><span class="line">&#125;).subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>merge(静态方法):根据时间线 合并多个observer</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Observable&lt;Long&gt; ob1 = Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">                .subscribeOn(Schedulers.newThread());</span><br><span class="line"></span><br><span class="line">        Observable&lt;Long&gt; ob2 = Observable.interval(50, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">                .map(aLong -&gt; aLong + 10)</span><br><span class="line">                .subscribeOn(Schedulers.newThread());</span><br><span class="line">        Observable.merge(ob1, ob2)</span><br><span class="line">                .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));</span><br><span class="line">日志结果:可以见出是根据时间线合并</span><br><span class="line">10	10	0	0	11	11	12	12	1	1	2	2</span><br></pre></td></tr></table></figure>

<ul>
<li>mergeWith:merge非静态写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ob1.mergeWith(ob2)</span><br><span class="line">               .subscribe(o -&gt; System.out.print( o + &quot;\t&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li>combineLatest(静态方法):使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值,它接受二到九个Observable作为参数 或者单 个Observables列表作为参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Long&gt; observable1 = Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">              .take(4)</span><br><span class="line">              .subscribeOn(Schedulers.newThread());</span><br><span class="line">      Observable&lt;Long&gt; observable2 = Observable.interval(200, TimeUnit.MILLISECONDS)</span><br><span class="line">              .take(5)</span><br><span class="line">              .subscribeOn(Schedulers.newThread());</span><br><span class="line">      Observable.combineLatest(observable1, observable2, (aLong, aLong2) -&gt; &#123;</span><br><span class="line">          System.out.print(&quot;aLong:&quot; + aLong + &quot;\t aLong2:&quot; + aLong2+&quot;\t&quot;);</span><br><span class="line">          return aLong + aLong2;</span><br><span class="line">      &#125;).subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line">  日志:</span><br><span class="line">  aLong:1	 aLong2:0	===&gt;1</span><br><span class="line">  aLong:2	 aLong2:0	===&gt;2</span><br><span class="line">  aLong:3	 aLong2:0	===&gt;3</span><br><span class="line">  aLong:3	 aLong2:1	===&gt;4</span><br><span class="line">  aLong:3	 aLong2:2	===&gt;5</span><br><span class="line">  aLong:3	 aLong2:3	===&gt;6</span><br><span class="line">  aLong:3	 aLong2:4	===&gt;7</span><br></pre></td></tr></table></figure>

<ul>
<li>withLatestFrom:类似zip ,但是只在单个原始Observable发射了一条数据时才发射数据,而不是两个都发</li>
</ul>
<blockquote>
<p>但是注意 如果没有合并元素 既辅助Observable一次都没发射的时候 是不发射数据的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">       Observable&lt;Long&gt; observable2 = Observable.interval(150, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(4)</span><br><span class="line">                .subscribeOn(Schedulers.newThread());</span><br><span class="line">        Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .withLatestFrom(observable2, (aLong, aLong2) -&gt; &#123;</span><br><span class="line">                    System.out.print(&quot;aLong:&quot; + aLong + &quot;\t aLong2:&quot; + aLong2 + &quot;\t&quot;);</span><br><span class="line">                    return aLong + aLong2;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">日志:</span><br><span class="line">明明原始take是3为啥不是三条log呢 因为原始的发送0的时候 ，辅助Observable还没发送过数据</span><br><span class="line">aLong:1	 aLong2:0	===&gt;1</span><br><span class="line">aLong:2	 aLong2:1	===&gt;3</span><br></pre></td></tr></table></figure>

<ul>
<li>switchMap:和flatMap类似,不同的是当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        Observable.interval(500, TimeUnit.MILLISECONDS)</span><br><span class="line">                .take(3)</span><br><span class="line">                .doOnNext(aLong -&gt; System.out.println())</span><br><span class="line">                .switchMap(aLong -&gt; Observable.intervalRange(aLong * 10, 3,</span><br><span class="line">                        0, 300, TimeUnit.MILLISECONDS)</span><br><span class="line">                        .subscribeOn(Schedulers.newThread()))</span><br><span class="line">                .subscribe(aLong -&gt; System.out.print(aLong+&quot;\t&quot;));</span><br><span class="line">解析：因为发送2的时候 intervalRange发送第三条数据的时候已经是600ms既 500ms的时候原始数据发送了。导致取消订阅前一个Observable</span><br><span class="line">所以 2 ,12没有发送 但是最后的22发送了 因为原始数据没有新发送的了</span><br><span class="line"></span><br><span class="line">//        日志结果</span><br><span class="line">//        0	1</span><br><span class="line">//        10	11</span><br><span class="line">//        20	21	22</span><br><span class="line">//        而不是</span><br><span class="line">//        0     1   2</span><br><span class="line">//        10	11  12</span><br><span class="line">//        20	21  22</span><br></pre></td></tr></table></figure>

<ul>
<li>startWith:是concat()的对应部分,在Observable开始发射他们的数据之前,startWith()通过传递一个参数来先发射一个数据序列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   Observable.just(&quot;old&quot;)</span><br><span class="line">                  &lt;!-- 简化版本 T item  --&gt;</span><br><span class="line">                  .startWith(&quot;Start&quot;)</span><br><span class="line">                  &lt;!--  多次应用探究 --&gt;</span><br><span class="line">                  .startWith(&quot;Start2&quot;)</span><br><span class="line">                  &lt;!--  observer --&gt;</span><br><span class="line">                  .startWith(Observable.just(&quot;Other Observable&quot;))</span><br><span class="line">                   &lt;!--  Iterable --&gt;</span><br><span class="line">                  .startWith(Arrays.asList(&quot;from Iterable&quot;))</span><br><span class="line">                   &lt;!--  T... --&gt;</span><br><span class="line">                  .startWithArray(&quot;from Array&quot;, &quot;from Array2&quot;)</span><br><span class="line">                  .subscribe(s -&gt; System.out.println(s));</span><br><span class="line">日志:</span><br><span class="line">from Array</span><br><span class="line">from Array2</span><br><span class="line">from Iterable</span><br><span class="line">Other Observable</span><br><span class="line">Start2</span><br><span class="line">Start</span><br><span class="line">old</span><br></pre></td></tr></table></figure>

<ul>
<li>join:任何时候，只要在另一个Observable发射的数据定义的时间窗口内，这个Observable发射了。一条数据，就结合两个Observable发射的数据</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcgy1fhzely2zzjj31am0r2go8.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 此demo 好使但是未让能理解透彻  仅仅想测试能结果的任用  想明白的话 此demo无效 --&gt;</span><br><span class="line">Observable.intervalRange(10, 4, 0, 300, TimeUnit.MILLISECONDS)</span><br><span class="line">           .join(Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">                           .take(7)</span><br><span class="line">                   , aLong -&gt; &#123;</span><br><span class="line">                       System.out.println(&quot;开始收集：&quot;+aLong);</span><br><span class="line">                       return Observable.just(aLong);</span><br><span class="line">                   &#125;</span><br><span class="line">                   , aLong -&gt; Observable.timer(200, TimeUnit.MILLISECONDS)</span><br><span class="line">                   , (aLong, aLong2) -&gt; &#123;</span><br><span class="line">                       System.out.print(&quot;aLong:&quot; + aLong + &quot;\t aLong2:&quot; + aLong2 + &quot;\t&quot;);</span><br><span class="line">                       return aLong + aLong2;</span><br><span class="line">                   &#125;</span><br><span class="line">           )</span><br><span class="line">           .subscribe(aLong -&gt; System.out.println(aLong));</span><br></pre></td></tr></table></figure>

<h2 id="条件操作"><a href="#条件操作" class="headerlink" title="条件操作"></a>条件操作</h2><ul>
<li><p>all:判定是否Observable发射的所有数据都满足某个条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> Observable.just(2, 3, 4)</span><br><span class="line">                .all(integer -&gt; integer &gt; 3)</span><br><span class="line">                .subscribe((aBoolean, throwable) -&gt; System.out.println(aBoolean));</span><br><span class="line">日志：false</span><br></pre></td></tr></table></figure>
</li>
<li><p>amb:给定多个Observable，只让第一个发射数据的Observable发射全部数据</p>
<ul>
<li><p>ambArray(静态方法):根据测试结果这个静态方法发射的最后一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Observable.ambArray(</span><br><span class="line">            Observable.intervalRange(0, 3, 200, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">            , Observable.intervalRange(10, 3, 300, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">            , Observable.intervalRange(20, 3, 100, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">    )</span><br><span class="line">            .doOnComplete(() -&gt; System.out.println(&quot;Complete&quot;))</span><br><span class="line">            .subscribe(aLong -&gt; System.out.println(aLong));</span><br><span class="line">日志：</span><br><span class="line">20  21  22  Complete</span><br></pre></td></tr></table></figure>
</li>
<li><p>ambWith:这个发射原始的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Observable.intervalRange(0, 3, 200, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">                .ambWith(Observable.intervalRange(10, 3, 300, 100, TimeUnit.MILLISECONDS))</span><br><span class="line">                .doOnComplete(() -&gt; System.out.println(&quot;Complete&quot;))</span><br><span class="line">                .subscribe(aLong -&gt; System.out.println(aLong));</span><br><span class="line">日志：</span><br><span class="line">0   1   2   Complete</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>contains:判定一个Observable是否发射一个特定的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(2, 3, 4)</span><br><span class="line">                .contains(2)</span><br><span class="line">                .subscribe((aBoolean, throwable) -&gt; System.out.println(aBoolean));</span><br></pre></td></tr></table></figure>
</li>
<li><p>switchIfEmpty:如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">        .switchIfEmpty(Observable.just(2, 3, 4))</span><br><span class="line">        .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)); //2,3,4</span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultIfEmpty:发射来自原始Observable的值，如果原始Observable没有发射任何值，就发射一个默认值,内部调用的switchIfEmpty。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">           .defaultIfEmpty(1)</span><br><span class="line">           .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)); //1</span><br></pre></td></tr></table></figure>
</li>
<li><p>sequenceEqual:判定两个Observables是否发射相同的数据序列。（数据，发射顺序，终止状态）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Observable.sequenceEqual(</span><br><span class="line">                Observable.just(2, 3, 4)</span><br><span class="line">                , Observable.just(2, 3, 4))</span><br><span class="line">                .subscribe((aBoolean, throwable) -&gt; System.out.println(aBoolean));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 它还有一个版本接受第三个参数，可以传递一个函数用于比较两个数据项是否相同。 --&gt;</span><br><span class="line">Observable.sequenceEqual(</span><br><span class="line">        Observable.just(2, 3, 4)</span><br><span class="line">        , Observable.just(2, 3, 4)</span><br><span class="line">        , (integer, integer2) -&gt; integer + 1 == integer2)</span><br><span class="line">        .subscribe((aBoolean, throwable) -&gt; System.out.println(aBoolean));</span><br></pre></td></tr></table></figure>
</li>
<li><p>skipUntil:丢弃原始Observable发射的数据，直到第二个Observable发射了一项数据</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.intervalRange(30, 20, 500, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">        .skipUntil(Observable.timer(1000, TimeUnit.MILLISECONDS))</span><br><span class="line">        .doOnNext(integer -&gt; System.out.println(integer))</span><br><span class="line">        //此时用这个主要是 测试环境 有执行时间 所以用阻塞比较好</span><br><span class="line">        .blockingSubscribe();</span><br></pre></td></tr></table></figure>

<ul>
<li>skipWhile:丢弃Observable发射的数据，直到一个指定的条件不成立</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3,4)</span><br><span class="line">               //从2开始 因为2条件不成立</span><br><span class="line">               .skipWhile(aLong -&gt; aLong==1)</span><br><span class="line">               .doOnNext(integer -&gt; System.out.println(integer))</span><br><span class="line">               //此时用这个主要是 测试环境 有执行时间 所以用阻塞比较好</span><br><span class="line">               .blockingSubscribe();</span><br></pre></td></tr></table></figure>

<ul>
<li>takeUntil:当第二个Observable发射了一项数据或者终止时，丢弃原始Observable发射的任何数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 条件变体 --&gt;</span><br><span class="line">Observable.just(2,3,4,5)</span><br><span class="line">             .takeUntil(integer -&gt;  integer&lt;=4)</span><br><span class="line">             .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));//2,3,4</span><br><span class="line">&lt;!-- Observable变体 --&gt;</span><br><span class="line">Observable.intervalRange(30, 20, 500, 100, TimeUnit.MILLISECONDS)</span><br><span class="line">             .takeUntil(Observable.timer(1000, TimeUnit.MILLISECONDS))</span><br><span class="line">             .doOnNext(integer -&gt; System.out.println(integer))</span><br><span class="line">             .doOnComplete(() -&gt; System.out.println(&quot;Complete&quot;))</span><br><span class="line">             //此时用这个主要是 测试环境 有执行时间 所以用阻塞比较好</span><br><span class="line">             .blockingSubscribe();</span><br></pre></td></tr></table></figure>

<ul>
<li>takeWhile:发射Observable发射的数据，直到一个指定的条件不成立</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(2,3,4,5)</span><br><span class="line">        .takeWhile(integer -&gt;integer&lt;=4 )</span><br><span class="line">        .subscribe(o -&gt; System.out.print(o + &quot;\t&quot;));//2,3</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ul>
<li><p>onErrorReturn:让Observable遇到错误时发射一个特殊的项并且正常终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 遇到错误处理范例 --&gt;</span><br><span class="line">Observable.error(new Throwable(&quot;我擦 空啊&quot;))</span><br><span class="line">            .onErrorReturnItem(&quot;hei&quot;)</span><br><span class="line">            .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                    , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                    , () -&gt; System.out.println(&quot;===&gt;complete&quot;));</span><br><span class="line">日志:</span><br><span class="line">===&gt;hei</span><br><span class="line">===&gt;complete</span><br><span class="line"></span><br><span class="line">&lt;!--  遇到错误不处理范例 --&gt;</span><br><span class="line">  Observable.error(new Throwable(&quot;我擦 空啊&quot;))</span><br><span class="line">                .onErrorReturn(throwable -&gt; &#123;</span><br><span class="line">                    System.out.println(&quot;错误信息：&quot; + throwable.getMessage());</span><br><span class="line">                    return throwable;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt;complete&quot;));</span><br><span class="line">日志:</span><br><span class="line">错误信息：我擦 空啊</span><br><span class="line">===&gt;java.lang.Throwable: 我擦 空啊</span><br><span class="line">===&gt;complete</span><br></pre></td></tr></table></figure>
</li>
<li><p>resumeNext:让Observable在遇到错误时开始发射第二个Observable的数据序列</p>
<ul>
<li><p>onErrorResumeNext:可以处理所有的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.error(new Throwable(&quot;我擦 空啊&quot;))</span><br><span class="line">              .onErrorResumeNext(throwable -&gt; &#123;</span><br><span class="line">                  System.out.println(&quot;错误信息：&quot; + throwable.getMessage());</span><br><span class="line">                  return Observable.range(0, 3);</span><br><span class="line">              &#125;)</span><br><span class="line">         .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                           , throwable -&gt; System.out.print(&quot;===&gt;throwable&quot;+ &quot;\t&quot;)</span><br><span class="line">                           , () -&gt; System.out.print(&quot;===&gt;complete&quot;+ &quot;\t&quot;));</span><br><span class="line">  日志：</span><br><span class="line">  错误信息：我擦 空啊</span><br><span class="line">  ===&gt;0	===&gt;1	===&gt;2	===&gt;complete</span><br></pre></td></tr></table></figure>
</li>
<li><p>onExceptionResumeNext:只能处理异常。</p>
<blockquote>
<p>Throwable 不是一个 Exception ,它会将错误传递给观察者的 onError 方法，不会使用备用 的Observable。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Throwable不能处理范例 --&gt;</span><br><span class="line">Observable.error(new Throwable(&quot;我擦 空啊&quot;))</span><br><span class="line">              .onExceptionResumeNext(observer -&gt; Observable.range(0, 3))</span><br><span class="line">              .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                      , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                      , () -&gt; System.out.println(&quot;===&gt;complete&quot;));</span><br><span class="line">  日志:</span><br><span class="line">  ===&gt;throwable</span><br><span class="line">  &lt;!-- 正确演示范例 无效ing 求解答~ todo --&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>retry:如果原始Observable遇到错误，重新订阅它期望它能正常终止</p>
<ul>
<li><p>变体count 重复次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(e -&gt; &#123;</span><br><span class="line">     e.onNext(1);</span><br><span class="line">     e.onNext(2);</span><br><span class="line">     e.onError(new Throwable(&quot;hehe&quot;));</span><br><span class="line"> &#125;)</span><br><span class="line">         .retry(2)</span><br><span class="line">         .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                 , throwable -&gt; System.out.print(&quot;===&gt;throwable\t&quot;)</span><br><span class="line">                 , () -&gt; System.out.print(&quot;===&gt;complete\t&quot;));</span><br><span class="line"> 日志:</span><br><span class="line"> ===&gt;1	===&gt;2	===&gt;1	===&gt;2	===&gt;1	===&gt;2	===&gt;throwable</span><br></pre></td></tr></table></figure>
</li>
<li><p>变体Predicate 条件判定 如果返回 true retry,false 放弃 retry</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(e -&gt; &#123;</span><br><span class="line">     e.onNext(1);</span><br><span class="line">     e.onNext(2);</span><br><span class="line">     e.onError(new Throwable(&quot;hehe&quot;));</span><br><span class="line"> &#125;)</span><br><span class="line">         .retry(throwable -&gt; throwable.getMessage().equals(&quot;hehe1&quot;))</span><br><span class="line">         .subscribe(o -&gt; System.out.print(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                 , throwable -&gt; System.out.print(&quot;===&gt;throwable\t&quot;)</span><br><span class="line">                 , () -&gt; System.out.print(&quot;===&gt;complete\t&quot;));</span><br><span class="line"> 日志:</span><br><span class="line">===&gt;1	===&gt;2	===&gt;throwable</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>retryWhen: 需要一个Observable 通过判断 throwableObservable,Observable发射一个数据 就重新订阅，发射的是 onError 通知，它就将这个通知传递给观察者然后终止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  &lt;!-- 正常范例 --&gt;</span><br><span class="line">  Observable.just(1, &quot;2&quot;, 3)</span><br><span class="line">                .cast(Integer.class)</span><br><span class="line">                &lt;!-- 结果：1,1,complete 原因这个Observable发了一次数据 --&gt;</span><br><span class="line">                .retryWhen(throwableObservable -&gt; Observable.timer(1, TimeUnit.SECONDS))</span><br><span class="line">                &lt;!-- 结果：1,1,1,1,complete 原因这个Observable发了三次数据 --&gt;</span><br><span class="line">                .retryWhen(throwableObservable -&gt; Observable.interval(1, TimeUnit.SECONDS)</span><br><span class="line">                    .take(3))</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;retryWhen 1===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;retryWhen 1===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;retryWhen 1===&gt;complete&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 通过判断throwable 进行处理范例 --&gt;</span><br><span class="line">    Observable.just(1, &quot;2&quot;, 3)</span><br><span class="line">                .cast(Integer.class)</span><br><span class="line">                .retryWhen(throwableObservable -&gt; &#123;</span><br><span class="line">                    return throwableObservable.switchMap(throwable -&gt; &#123;</span><br><span class="line">                        if (throwable instanceof IllegalArgumentException)</span><br><span class="line">                            return Observable.just(throwable);</span><br><span class="line">                            &lt;!-- 这种方式OK --&gt;</span><br><span class="line">//                        else&#123;</span><br><span class="line">//                            PublishSubject&lt;Object&gt; pb = PublishSubject.create();</span><br><span class="line">//                            pb .onError(throwable);</span><br><span class="line">//                            return pb;</span><br><span class="line">//                        &#125;</span><br><span class="line">                        else</span><br><span class="line">                            //方法泛型</span><br><span class="line">                            return Observable.&lt;Object&gt;error(throwable);</span><br><span class="line">                          &lt;!-- 这种方式也OK --&gt;</span><br><span class="line">//                        return Observable.just(1).cast(String.class);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;retryWhen 2===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;retryWhen 2===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;retryWhen 2===&gt;complete&quot;));</span><br><span class="line">日志:</span><br><span class="line">retryWhen 2===&gt;1</span><br><span class="line">retryWhen 2===&gt;throwable</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h2><ul>
<li><p>toList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">              .toList().blockingGet()</span><br><span class="line">              .forEach(aLong -&gt; System.out.println(aLong));</span><br></pre></td></tr></table></figure>
</li>
<li><p>toSortList</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(5, 2, 3)</span><br><span class="line">           .toSortedList()</span><br><span class="line">           .blockingGet()</span><br><span class="line">           .forEach(integer -&gt; System.out.println(integer))</span><br></pre></td></tr></table></figure>
</li>
<li><p>toMap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     Map&lt;String, Integer&gt; map = Observable.just(5, 2, 3)</span><br><span class="line">//                .toMap(integer -&gt; integer + &quot;_&quot;)</span><br><span class="line">                //key 就是5_,value就是5+10   mapSupplier map提供者</span><br><span class="line">                .toMap(integer -&gt; integer + &quot;_&quot;</span><br><span class="line">                        , integer -&gt; integer + 10</span><br><span class="line">                        , () -&gt; new HashMap&lt;&gt;())</span><br><span class="line">                .blockingGet();</span><br></pre></td></tr></table></figure>
</li>
<li><p>toFuture</p>
<blockquote>
<p>这个操作符将Observable转换为一个返 回单个数据项的 Future   带有返回值的任务<br>如果原始Observable发射多个数据项， Future 会收到1个 IllegalArgumentException<br>如果原始Observable没有发射任何数据， Future 会收到一 个 NoSuchElementException<br>如果你想将发射多个数据项的Observable转换为 Future ,可以这样 用: myObservable.toList().toFuture()</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">                   .toList()//转换成Single&lt;List&lt;T&gt;&gt; 这样就变成一个数据了</span><br><span class="line">                   .toFuture()</span><br><span class="line">                   .get()</span><br><span class="line">                   .forEach(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>blockingSubscribe</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3)</span><br><span class="line">              .blockingSubscribe(integer -&gt; System.out.println(integer));</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingForEach:对BlockingObservable发射的每一项数据调用一个方法，会阻塞直到Observable完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">        .doOnNext(aLong -&gt; &#123;</span><br><span class="line">            if (aLong == 10)</span><br><span class="line">                throw new RuntimeException();</span><br><span class="line">        &#125;).onErrorReturnItem(-1L)</span><br><span class="line">        .blockingForEach(aLong -&gt; System.out.println(aLong));</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingIterable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   Observable.just(1, 2, 3)</span><br><span class="line">                .blockingIterable()</span><br><span class="line">//                .blockingIterable(5);</span><br><span class="line">                .forEach(aLong -&gt; System.out.println(&quot;aLong:&quot; + aLong));</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingFirst</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.empty()</span><br><span class="line">   // .blockingFirst();</span><br><span class="line">   //带默认值版本</span><br><span class="line">    .blockingFirst(-1));</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingLast：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1,2,3)</span><br><span class="line">      // .blockingLast();</span><br><span class="line">      //带默认值版本</span><br><span class="line">       .blockingLast(-1));</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingMostRecent:返回一个总是返回Observable最近发射的数据的Iterable,类似于while的感觉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Iterable&lt;Long&gt; c = Observable.interval(100, TimeUnit.MILLISECONDS)</span><br><span class="line">            .doOnNext(aLong -&gt; &#123;</span><br><span class="line">                if (aLong == 10)</span><br><span class="line">                    throw new RuntimeException();</span><br><span class="line">            &#125;).onErrorReturnItem(-1L)</span><br><span class="line">            .blockingMostRecent(-3L);</span><br><span class="line">for (Long aLong : c) &#123;</span><br><span class="line">            System.out.println(&quot;aLong:&quot; + aLong);</span><br><span class="line">        &#125;</span><br><span class="line">日志很长 可以自己一试变知</span><br></pre></td></tr></table></figure>
</li>
<li><p>blockingSingle:</p>
</li>
</ul>
<blockquote>
<p>终止时只发射了一个值，返回那个值<br> empty   无默认值 报错， 默认值的话显示默认值<br>多个值的话  有无默认值都报错</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;emit 1 value:&quot; + Observable.just(1).blockingSingle());</span><br><span class="line">System.out.println(&quot;default empty single:&quot; + Observable.empty().blockingSingle(-1));</span><br><span class="line">System.out.println(&quot;default emit 1 value:&quot; + Observable.just(1).blockingSingle(-1));</span><br><span class="line">try &#123;</span><br><span class="line">    System.out.println(&quot;empty single:&quot; + Observable.empty().blockingSingle());</span><br><span class="line">    System.out.println(&quot;emit many value:&quot; + Observable.just(1, 2).blockingSingle());</span><br><span class="line">    System.out.println(&quot;default emit many value:&quot; + Observable.just(1, 2)</span><br><span class="line">            .blockingSingle(-1));</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">日志:</span><br><span class="line">emit 1 value:1</span><br><span class="line">default empty single:-1</span><br><span class="line">default emit 1 value:1</span><br><span class="line">java.util.NoSuchElementException</span><br></pre></td></tr></table></figure>

<h2 id="组合操作"><a href="#组合操作" class="headerlink" title="组合操作"></a>组合操作</h2><ul>
<li>compose:有多个 Observable ，并且他们都需要应用<code>一组相同的 变换</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  用一个工具类去写 这样符合单一职责 --&gt;</span><br><span class="line">//composes 工具类</span><br><span class="line">public class RxComposes &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; applyObservableAsync() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Observable.empty()</span><br><span class="line">                .compose(RxComposes.applyObservableAsync())</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(&quot;ob3:&quot; + integer));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ConnectableObservable：可连接的Observable在 被订阅时并不开始发射数据，只有在它的 connect() 被调用时才开始用这种方法，<br>你可以 等所有的潜在订阅者都订阅了这个Observable之后才开始发射数据。即使没有任何订阅者订阅它，你也可以使用 connect 让他发射</p>
<ul>
<li><p>replay(Observable的方法): 每次订阅 都对单个订阅的重复播放一边</p>
<ul>
<li>bufferSize:对源发射队列的缓存数量, 从而对新订阅的进行发射；</li>
</ul>
<blockquote>
<p>Observable的方法 返回是ConnectableObservable<br>切记要让ConnectableObservable具有重播的能力,必须Obserable的时候调用replay,而不是ConnectableObservable 的时候调用replay</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//this  is  OK,too!</span><br><span class="line">     ConnectableObservable&lt;Integer&gt; co = Observable.just(1, 2, 3)</span><br><span class="line">             //类似 publish直接转成 ConnectableObservable  切记要重复播放的话必须Obserable的时候调用replay</span><br><span class="line">             //而不是ConnectableObservable 的时候调用replay 所以 .publish().replay()则无效</span><br><span class="line">             .replay(3);//重复播放的 是1  2  3</span><br><span class="line">//           .replay(2);//重复播放的 是 2  3</span><br><span class="line"></span><br><span class="line">     co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅1：&quot;))</span><br><span class="line">             .doFinally(() -&gt; System.out.println())</span><br><span class="line">             .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line">     co.connect();//此时开始发射数据 不同与 refCount 只发送一次</span><br><span class="line"></span><br><span class="line">     co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅2：&quot;))</span><br><span class="line">             .doFinally(() -&gt; System.out.println())</span><br><span class="line">             .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">     co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅3：&quot;))</span><br><span class="line">             .doFinally(() -&gt; System.out.println())</span><br><span class="line">             .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">replay(3)日志：只能缓存原始队列的两个【1,2,3】</span><br><span class="line">订阅1：1	2	3</span><br><span class="line">订阅2：1	2	3</span><br><span class="line">订阅3：1	2	3</span><br><span class="line"></span><br><span class="line">replay(2)日志：只能缓存原始队列的两个【2,3】</span><br><span class="line">订阅1：1	2	3</span><br><span class="line">订阅2：	2	3</span><br><span class="line">订阅3：	2	3</span><br></pre></td></tr></table></figure>
</li>
<li><p>publish(Observable的方法):将普通的Observable转换为可连接的Observable</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ConnectableObservable&lt;Integer&gt; co = Observable.just(1, 2, 3)</span><br><span class="line">               .publish();</span><br><span class="line"></span><br><span class="line">       co.subscribe(integer -&gt; System.out.println(&quot;订阅1：&quot; + integer));</span><br><span class="line">       co.subscribe(integer -&gt; System.out.println(&quot;订阅2：&quot; + integer));</span><br><span class="line">       co.subscribe(integer -&gt; System.out.println(&quot;订阅3：&quot; + integer));</span><br><span class="line">       co.connect();//此时开始发射数据</span><br></pre></td></tr></table></figure>

<ul>
<li>refCount(ConnectableObservable的方法): 操作符把从一个可连接的Observable连接和断开的过程自动化了, 就像reply的感觉式样 每次订阅 都对单个订阅的重复播放一边<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> Observable&lt;Integer&gt; co = Observable.just(1, 2, 3)</span><br><span class="line">                .publish()</span><br><span class="line">                //类似于reply  跟时间线有关  订阅开始就开始发送</span><br><span class="line">                .refCount();</span><br><span class="line"></span><br><span class="line">        co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅1：&quot;))</span><br><span class="line">                .doFinally(() -&gt; System.out.println())</span><br><span class="line">                .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line">        co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅2：&quot;))</span><br><span class="line">                .doFinally(() -&gt; System.out.println())</span><br><span class="line">                .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line"></span><br><span class="line">        Observable.timer(300, TimeUnit.MILLISECONDS)</span><br><span class="line">                .doOnComplete(() -&gt; &#123;</span><br><span class="line">                    co.doOnSubscribe(disposable -&gt; System.out.print(&quot;订阅3：&quot;))</span><br><span class="line">                            .doFinally(() -&gt; System.out.println())</span><br><span class="line">                            .subscribe(integer -&gt; System.out.print(integer + &quot;\t&quot;));</span><br><span class="line">                &#125;).blockingSubscribe();</span><br><span class="line">日志:</span><br><span class="line">订阅1：1	2	3</span><br><span class="line">订阅2：1	2	3</span><br><span class="line">订阅3：1	2	3</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Subjects"><a href="#Subjects" class="headerlink" title="Subjects"></a>Subjects</h2><p>Subject可以看成是一个桥梁或者代理，在某些ReactiveX实现中(如RxJava)，它同时充当 了Observer和Observable的角色。因为它是一个Observer，它可以订阅一个或多个 Observable;又因为它是一个Observable，它可以转发它收到(Observe)的数据，也可以发射 新的数据。</p>
<blockquote>
<p>对我来说为什么用subjects呢？所有Subject都可以直接发射,不需要 发射器的引用 和 Observable.create()不同</p>
</blockquote>
<ul>
<li>AsyncSubject:简单的说使用AsyncSubject无论输入多少参数，永远只输出最后一个参数。<blockquote>
<p>但是如果因为发生了错误而终止，AsyncSubject将不会发射任何数据，只是简单的向前传递这个错误通知。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AsyncSubject&lt;Integer&gt; source = AsyncSubject.create();</span><br><span class="line"></span><br><span class="line">    source.subscribe(o -&gt; System.out.println(&quot;1:&quot;+o)); // it will emit only 4 and onComplete</span><br><span class="line"></span><br><span class="line">    source.onNext(1);</span><br><span class="line">    source.onNext(2);</span><br><span class="line">    source.onNext(3);</span><br><span class="line"></span><br><span class="line">     &lt;!-- it will emit 4 and onComplete for second observer also. --&gt;</span><br><span class="line">    source.subscribe(o -&gt; System.out.println(&quot;2:&quot;+o));</span><br><span class="line"></span><br><span class="line">    source.onNext(4);</span><br><span class="line">    source.onComplete();</span><br><span class="line">    日志:</span><br><span class="line">    1:4</span><br><span class="line">    2:4</span><br></pre></td></tr></table></figure>

<ul>
<li>BehaviorSubject:会发送离订阅最近的上一个值，没有上一个值的时候会发送默认值。</li>
</ul>
<blockquote>
<p>如果原始的Observable因为发生了一个错误而终止，BehaviorSubject将不会发射任何 数据，只是简单的向前传递这个错误通知。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> BehaviorSubject&lt;Integer&gt; source = BehaviorSubject.create();</span><br><span class="line">        //默认值版本</span><br><span class="line">//        BehaviorSubject&lt;Integer&gt; source = BehaviorSubject.createDefault(-1);</span><br><span class="line"></span><br><span class="line">        source.subscribe(o -&gt; System.out.println(&quot;1:&quot;+o)); // it will get 1, 2, 3, 4 and onComplete</span><br><span class="line"></span><br><span class="line">        source.onNext(1);</span><br><span class="line">        source.onNext(2);</span><br><span class="line">        source.onNext(3);</span><br><span class="line"></span><br><span class="line">        &lt;!-- it will emit 3(last emitted), 4 and onComplete for second observer also. --&gt;</span><br><span class="line">        source.subscribe(o -&gt; System.out.println(&quot;2:&quot;+o));</span><br><span class="line"></span><br><span class="line">        source.onNext(4);</span><br><span class="line">        source.onComplete();</span><br><span class="line">        日志:</span><br><span class="line">        1:1</span><br><span class="line">        1:2</span><br><span class="line">        1:3</span><br><span class="line">        2:3</span><br><span class="line">        1:4</span><br><span class="line">        2:4</span><br></pre></td></tr></table></figure>

<ul>
<li><code>publishSubject</code>(subject里最常用的):可以说是最正常的Subject，从那里订阅就从那里开始发送数据。<blockquote>
<p>如果原始的Observable因为发生了一个错误而终止，PublishSubject将不会发射任何数据，只 是简单的向前传递这个错误通知。</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PublishSubject bs = PublishSubject.create();</span><br><span class="line"></span><br><span class="line">        bs.subscribe(o -&gt; System.out.println(&quot;1:&quot;+o));</span><br><span class="line">        bs.onNext(1);</span><br><span class="line">        bs.onNext(2);</span><br><span class="line">        bs.subscribe(o -&gt; System.out.println(&quot;2:&quot;+o));</span><br><span class="line">        bs.onNext(3);</span><br><span class="line">        bs.onComplete();</span><br><span class="line">        bs.subscribe(o -&gt; System.out.println(&quot;3:&quot;+o));</span><br><span class="line">        日志：</span><br><span class="line">        1:1</span><br><span class="line">        1:2</span><br><span class="line">        1:3</span><br><span class="line">        2:3</span><br></pre></td></tr></table></figure>

<ul>
<li>replaySubject: 无论何时订阅，都会将所有历史订阅内容全部发出。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        ReplaySubject bs = ReplaySubject.create();</span><br><span class="line"></span><br><span class="line">        bs.subscribe(o -&gt; System.out.println(&quot;1:&quot;+o));</span><br><span class="line">// 无论何时订阅都会收到1，2，3</span><br><span class="line">        bs.onNext(1);</span><br><span class="line">        bs.onNext(2);</span><br><span class="line">        bs.onNext(3);</span><br><span class="line">        bs.onComplete();</span><br><span class="line"></span><br><span class="line">        bs.subscribe(o -&gt; System.out.println(&quot;2:&quot;+o));</span><br><span class="line">        日志:</span><br><span class="line">        1:1</span><br><span class="line">        1:2</span><br><span class="line">        1:3</span><br><span class="line">        2:1</span><br><span class="line">        2:2</span><br><span class="line">        2:3</span><br></pre></td></tr></table></figure>

<h2 id="Single与Completable"><a href="#Single与Completable" class="headerlink" title="Single与Completable"></a>Single与Completable</h2><p>参考:<a href="http://developer.51cto.com/art/201703/535298.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201703/535298.htm</a></p>
<p>使用场景:其实这个网络请求并不是一个连续事件流，你只会发起一次 Get 请求返回数据并且只收到一个事件。我们都知道这种情况下 onComplete 会紧跟着 onNext 被调用，那为什么不把它们合二为一呢？</p>
<ul>
<li>Single:它总是只发射一个值，或者一个错误通知，而不是发射 一系列的值。因此，不同于Observable需要三个方法onNext, onError, onCompleted，订阅Single只需要两 个方法:</li>
</ul>
<blockquote>
<p>Single只会调用这两个方法中的一个，而且只会调用一次，调用了任何一个方法之后，订阅关 系终止。</p>
</blockquote>
<pre><code>* onSuccess - Single发射单个的值到这个方法
* onError - 如果无法发射需要的值，Single发射一个Throwable对象到这个方法</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  retrofit 范例--&gt;</span><br><span class="line"> public interface APIClient &#123;</span><br><span class="line"></span><br><span class="line">     @GET(&quot;my/api/path&quot;)</span><br><span class="line">     Single&lt;MyData&gt; getMyData();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> apiClient.getMyData()</span><br><span class="line">     .subscribe(new Consumer&lt;MyData&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void accept(MyData myData) throws Exception &#123;</span><br><span class="line">             // handle data fetched successfully and API call completed</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void accept(Throwable throwable) throws Exception&#123;</span><br><span class="line">             // handle error event</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;!-- 单独使用范例： --&gt;</span><br><span class="line">        Single.just(&quot;Amit&quot;)</span><br><span class="line">            .subscribe(s -&gt; System.out.println(s)</span><br><span class="line">                    , throwable -&gt; System.out.println(&quot;异常&quot;));</span><br></pre></td></tr></table></figure>

<p>使用场景:通过 PUT 请求更新数据 我只关心 onComplete 事件。使用 Completable 时我们忽略 onNext 事件，只处理 onComplete 和 onError 事件</p>
<ul>
<li>Completable:本质上来说和 Observable 与 Single 不一样，因为它不发射数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  retrofit 范例--&gt;</span><br><span class="line">public interface APIClient &#123;</span><br><span class="line"></span><br><span class="line">    @PUT(&quot;my/api/updatepath&quot;)</span><br><span class="line">    Completable updateMyData(@Body MyData data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apiClient.updateMyData(myUpdatedData)</span><br><span class="line">    .subscribe(new Action() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() throws Exception &#123;</span><br><span class="line">            // handle completion</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Throwable throwable) throws Exception&#123;</span><br><span class="line">            // handle error</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 单独使用范例： --&gt;</span><br><span class="line">     Completable.timer(1000, TimeUnit.MILLISECONDS)</span><br><span class="line">                    .subscribe(() -&gt; System.out.println(&quot;成功&quot;)</span><br><span class="line">                            , throwable -&gt; System.out.println(&quot;异常&quot;));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>andThen( Completable中的方法最常用):在这个操作符中你可以传任何Observable、Single、Flowable、Maybe或者其他Completable，它们会在原来的 Completable 结束后执行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiClient.updateMyData(myUpdatedData)</span><br><span class="line">    .andThen(performOtherOperation()) // a Single&lt;OtherResult&gt;</span><br><span class="line">    .subscribe(new Consumer&lt;OtherResult&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(OtherResult result) throws Exception &#123;</span><br><span class="line">            // handle otherResult</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, new Consumer&lt;Throwable&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void accept(Throwable throwable) throws Exception&#123;</span><br><span class="line">            // handle error</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="自定义操作符"><a href="#自定义操作符" class="headerlink" title="自定义操作符"></a>自定义操作符</h2><ul>
<li>lift 原理图</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/large/006tKfTcgy1fi33z4i9jlj30mi0gp74i.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void lift()&#123;</span><br><span class="line">            Observable.just(1,2)</span><br><span class="line">                    //也是代理模式  observer是真正订阅</span><br><span class="line">                    .lift(observer -&gt; new Observer&lt;Integer&gt;() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onSubscribe(Disposable d) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onNext(Integer integer) &#123;</span><br><span class="line">                            observer.onNext(integer+&quot;?&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onError(Throwable e) &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void onComplete() &#123;</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .subscribe(o -&gt; System.out.println(o));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    日志:</span><br><span class="line">    1?</span><br><span class="line">    2?</span><br></pre></td></tr></table></figure>

<h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><p>flatMap 与 zip 配合的实用范例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromArray(new File(&quot;/Users/fuzhipeng/Documents&quot;))</span><br><span class="line">               .flatMap(file -&gt; Observable.fromArray(file.listFiles()))</span><br><span class="line">               //比较经典的 就是Observable.just(file) 把 file一个元素转成 observer从而进行zip合并的难题解决了</span><br><span class="line">               .flatMap(file -&gt;</span><br><span class="line">                       Observable.zip(Observable.just(file)</span><br><span class="line">                               , Observable.timer(1, TimeUnit.SECONDS)</span><br><span class="line">                               , (file1, aLong) -&gt; file1))</span><br><span class="line">               .filter(file -&gt; file.getName().endsWith(&quot;.png&quot;))</span><br><span class="line">               .take(5)</span><br><span class="line">               .map(file -&gt; file.getName())</span><br><span class="line">               .subscribeOn(Schedulers.io())</span><br><span class="line">               .observeOn(Schedulers.newThread())</span><br><span class="line">               .subscribe(s -&gt; System.out.println(s));</span><br><span class="line">       while (true) &#123;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>map的实用范例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//有些服务几口设计，返回数据外层会包裹一些额外信息,可以使用map()吧外层格式剥掉</span><br><span class="line">       Observable.just(1)</span><br><span class="line">               .map(integer -&gt; new Integer[]&#123;1, 2, 3&#125;)</span><br><span class="line">               .subscribe(integers -&gt; System.out.println(integers));</span><br></pre></td></tr></table></figure>

<p>方法泛型的实用范例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, &quot;2&quot;, 3)</span><br><span class="line">                .cast(Integer.class)</span><br><span class="line">                .retryWhen(throwableObservable -&gt; &#123;</span><br><span class="line">                    return throwableObservable.switchMap(throwable -&gt; &#123;</span><br><span class="line">                        if (throwable instanceof IllegalArgumentException)</span><br><span class="line">                            return Observable.just(throwable);</span><br><span class="line">                        //todo  方法泛型 如果我不写&lt;Object&gt; 则会报错</span><br><span class="line">                        return Observable.&lt;Object&gt;error(throwable);</span><br><span class="line">                        //这个报错！！！</span><br><span class="line">//                        return Observable.error(throwable);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribe(o -&gt; System.out.println(&quot;===&gt;&quot; + o + &quot;\t&quot;)</span><br><span class="line">                        , throwable -&gt; System.out.println(&quot;===&gt;throwable&quot;)</span><br><span class="line">                        , () -&gt; System.out.println(&quot;===&gt;complete&quot;));</span><br></pre></td></tr></table></figure>

<p>BehaviorSubject的使用技巧:</p>
<blockquote>
<p>cache BehaviorSubject 是桥梁 并且有 发送最近的缓存特性！</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BehaviorSubject&lt;Object&gt; cache = BehaviorSubject.create();</span><br><span class="line">        Observable.timer(1,TimeUnit.SECONDS)</span><br><span class="line">                .subscribeOn(Schedulers.newThread())</span><br><span class="line">                .observeOn(Schedulers.newThread())</span><br><span class="line">                .subscribe(cache);</span><br><span class="line"></span><br><span class="line">        //可以想象成上面是方法  这里是方法被调用</span><br><span class="line">        cache.subscribe(o -&gt; System.out.println(o));//结果0</span><br></pre></td></tr></table></figure>

<p>Observable 发射元素的封装范例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//创建一个Observable 可以直接发送的 原因 获取rx内部方法需要final很恶心 所以...</span><br><span class="line">        RxEmitter&lt;Integer&gt; emitter = new RxEmitter();</span><br><span class="line">        Observable.create(emitter)</span><br><span class="line">                .subscribe(integer -&gt; System.out.println(integer));</span><br><span class="line">        emitter.onNext(1);</span><br><span class="line">        emitter.onNext(2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class RxEmitter&lt;T&gt; implements ObservableOnSubscribe&lt;T&gt;, ObservableEmitter&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ObservableEmitter&lt;T&gt; e;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void subscribe(ObservableEmitter&lt;T&gt; e) throws Exception &#123;</span><br><span class="line">        this.e = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(T value) &#123;</span><br><span class="line">        e.onNext(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable error) &#123;</span><br><span class="line">        e.onError(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onComplete() &#123;</span><br><span class="line">        e.onComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setDisposable(Disposable d) &#123;</span><br><span class="line">        e.setDisposable(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCancellable(Cancellable c) &#123;</span><br><span class="line">        e.setCancellable(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean isDisposed() &#123;</span><br><span class="line">        return e.isDisposed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ObservableEmitter&lt;T&gt; serialize() &#123;</span><br><span class="line">        return e.serialize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean tryOnError(Throwable t) &#123;</span><br><span class="line">        return e.tryOnError(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h2><p><a href="https://www.gitbook.com/book/mcxiaoke/rxdocs/details" target="_blank" rel="noopener">https://www.gitbook.com/book/mcxiaoke/rxdocs/details</a></p>
<blockquote>
<p>基本上所有的都参考此文档 很神！</p>
</blockquote>
<p><a href="http://blog.csdn.net/maplejaw_/article/details/52396175" target="_blank" rel="noopener">http://blog.csdn.net/maplejaw_/article/details/52396175</a></p>
<p><a href="http://developer.51cto.com/art/201703/535298.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201703/535298.htm</a></p>
<p><a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="noopener">http://gank.io/post/560e15be2dca930e00da1083</a></p>
<p><a href="https://github.com/amitshekhariitbhu/RxJava2-Android-Samples" target="_blank" rel="noopener">https://github.com/amitshekhariitbhu/RxJava2-Android-Samples</a></p>
<p><a href="http://www.jianshu.com/u/c50b715ccaeb" target="_blank" rel="noopener">http://www.jianshu.com/u/c50b715ccaeb</a></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="https://luhaoaimama1.github.io">Zone</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="https://luhaoaimama1.github.io/2017/07/31/rxjava/">https://luhaoaimama1.github.io/2017/07/31/rxjava/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <div class="post-reward">
    <input type="checkbox" name="reward" id="reward" hidden>
    <label class="reward-button" for="reward">赞赏支持</label>
    <div class="qr-code"><label class="qr-code-image" for="reward">
          <img class="image" src="/weixin.png" title="wechat">
        </label>
      </div>
  </div><footer class="post-footer">
        
        <nav class="post-nav"><a class="prev" href="/2017/08/11/Adapter3Absorb/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">ZAdapter3断头吸附效果</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    <a class="next" href="/2017/07/12/Adapter3HF/">
        <span class="next-text nav-default">Recycler下Adapter的HeaderFooter多个添加方式</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80Njg5My8yMzM5NA==">
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>  
    </div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:1149324777@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/luhaoaimama1" class="iconfont icon-github" title="github"></a>
        <a href="https://weibo.com/u/2193119237" class="iconfont icon-weibo" title="weibo"></a>
        <a href="https://luhaoaimama1.github.io/archives/" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2016 - 2022<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Zone</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript">
	(function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
  </script><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>

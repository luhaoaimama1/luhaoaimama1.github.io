<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zone</title>
  <subtitle>Just do it!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luhaoaimama1.github.io/"/>
  <updated>2017-04-28T18:27:43.000Z</updated>
  <id>https://luhaoaimama1.github.io/</id>
  
  <author>
    <name>Zone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>继承与链式调用的结合</title>
    <link href="https://luhaoaimama1.github.io/2017/04/29/chain/"/>
    <id>https://luhaoaimama1.github.io/2017/04/29/chain/</id>
    <published>2017-04-28T17:40:37.000Z</published>
    <updated>2017-04-28T18:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="父类-返回值是泛型；"><a href="#父类-返回值是泛型；" class="headerlink" title="父类:返回值是泛型；"></a>父类:返回值是泛型；</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Helper&lt;T</span> <span class="keyword">extends</span> <span class="title">Helper&gt;</span> </span>&#123;</div><div class="line">     <span class="keyword">protected</span> <span class="type">T</span> child;</div><div class="line">     public <span class="type">Helper</span>() &#123;</div><div class="line">            child = (<span class="type">T</span>) <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">     public <span class="type">T</span> setText(<span class="meta">@IdRes</span> int viewId,<span class="type">String</span> textStr) &#123;</div><div class="line">            ...</div><div class="line">            checkChild();</div><div class="line">            <span class="keyword">return</span> child;</div><div class="line">        &#125;</div><div class="line">     <span class="keyword">protected</span> void checkChild() &#123;</div><div class="line">            <span class="keyword">if</span> (child == <span class="literal">null</span>)</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"child must be set in child's Constructor!"</span> +</div><div class="line">                        <span class="string">"not method:initDefaultValueAnimator"</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="子类-制定泛型-继承父类"><a href="#子类-制定泛型-继承父类" class="headerlink" title="子类:制定泛型 + 继承父类"></a>子类:制定泛型 + 继承父类</h1><ul>
<li>光继承，就已经包含扩展能力了。</li>
<li>warpper方法其实装饰器模式<blockquote>
<p>用到的地方:例如一个方法的参数是Helper类型，并且无法改变参数的类型。继而用装饰器扩展其功能</p>
</blockquote>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ExtraHelper&lt;T</span> <span class="keyword">extends</span> <span class="title">ExtraHelper&gt;</span> <span class="keyword">extends</span> <span class="title">Helper&lt;T&gt;</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="type">ExtraHelper</span>(<span class="type">Helper</span> helper) &#123;</div><div class="line">        <span class="keyword">super</span>(helper.getContext(), helper.getHolder(), helper.getAdapter());</div><div class="line">        child = (<span class="type">T</span>) <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static <span class="type">ExtraHelper</span>&lt;<span class="type">ExtraHelper</span>&gt; wrapper(<span class="type">Helper</span> helper) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ExtraHelper</span>(helper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public <span class="type">T</span> heihei() &#123;</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"heihei!"</span>);</div><div class="line">        checkChild();</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public <span class="type">T</span> heihei2() &#123;</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"heihei2!"</span>);</div><div class="line">        checkChild();</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后的使用"><a href="#最后的使用" class="headerlink" title="最后的使用"></a>最后的使用</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ExtraHelper</span><span class="selector-class">.wrapper</span>(<span class="selector-tag">helper</span>)<span class="selector-class">.setText</span>(<span class="selector-tag">R</span><span class="selector-class">.id</span><span class="selector-class">.tv</span>, <span class="selector-tag">data</span>)<span class="selector-class">.heihei</span>()<span class="selector-class">.heihei2</span>()</div></pre></td></tr></table></figure>
<p><a href="https://github.com/luhaoaimama1/ZAdapter3/blob/master/app/src/main/java/zone/com/zadapter3/helper/ExtraHelper.java" target="_blank" rel="external">Demo</a><br><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/gson%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8F%8D%E5%B0%84/%E7%BB%A7%E6%89%BF%E6%B3%9B%E5%9E%8B%E7%A0%94%E7%A9%B6/Main.java" target="_blank" rel="external">Demo2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;父类-返回值是泛型；&quot;&gt;&lt;a href=&quot;#父类-返回值是泛型；&quot; class=&quot;headerlink&quot; title=&quot;父类:返回值是泛型；&quot;&gt;&lt;/a&gt;父类:返回值是泛型；&lt;/h1&gt;&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;public &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Helper&amp;lt;T&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Helper&amp;gt;&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt; child;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     public &lt;span class=&quot;type&quot;&gt;Helper&lt;/span&gt;() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            child = (&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     public &lt;span class=&quot;type&quot;&gt;T&lt;/span&gt; setText(&lt;span class=&quot;meta&quot;&gt;@IdRes&lt;/span&gt; int viewId,&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; textStr) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            checkChild();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; child;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; void checkChild() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (child == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;IllegalStateException&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;child must be set in child&#39;s Constructor!&quot;&lt;/span&gt; +&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;string&quot;&gt;&quot;not method:initDefaultValueAnimator&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZAdapter3的分析与撸库</title>
    <link href="https://luhaoaimama1.github.io/2017/04/29/Adapter3/"/>
    <id>https://luhaoaimama1.github.io/2017/04/29/Adapter3/</id>
    <published>2017-04-28T16:19:37.000Z</published>
    <updated>2017-04-28T17:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析时候的思路"><a href="#分析时候的思路" class="headerlink" title="分析时候的思路"></a>分析时候的思路</h1><ul>
<li>adapter里面的viewhold可以被复用<blockquote>
<p>所以需要重写一个方法通过位置获取layoutStyle，addviewHolder顺便传递一个layoutStyle,也可不传为默认值；</p>
</blockquote>
</li>
<li>layoutID要在viewhold的类方法中,而不是构造器中 <blockquote>
<p>  因为resID与viewHold本就是一个整体。方法构造中的话表示resID是可变的，并且看到这个viewhold类的时候布局文件看不到 容易蒙蔽</p>
</blockquote>
</li>
<li>helper类与ButterKnife的取舍?<blockquote>
<p>helper比ButterKnife好,原因:可定制封装逻辑，不强转，可连写,可通过泛型+继承+装饰模式达到扩展的目的；</p>
</blockquote>
</li>
<li><p>adapter 可扩展+链式调用  是用 泛型+继承 还是 同一个接口呢？</p>
<blockquote>
<p>泛型+继承 :在IDEA中是可以的。但是AS中出现了bug。我已经向google提意见了,估计不会吊我~<br><img src="https://ww2.sinaimg.cn/large/006tNc79gy1ff2v3z7mq0j31a20cewg6.jpg" alt=""><br>所以退而求其次 选择同一个接口</p>
</blockquote>
</li>
<li><p>基础功能 </p>
<blockquote>
<p>addViewHold(ViewHolder)//为default<br>addViewHold(style,viewHolder)<br>addHeaderHold(ViewHolder/resId)<br>addFooterHold(ViewHolder/resId)<br>addEmptyHold(ViewHolder/resId)<br>notify系列<br>notifyEx系列(这里的位置对应为数据集的位置。包括header/footer)<br>relaeList(rv) 故事的开始。很多逻辑可以在这里完成  </p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<h1 id="书写类型初稿："><a href="#书写类型初稿：" class="headerlink" title="书写类型初稿："></a>书写类型初稿：</h1><p>Adapter<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">new</span> <span class="title">Adatper</span>(context,data)&#123;</span></div><div class="line">	<span class="title">o</span>.<span class="title">getStyle</span>()&lt;——可不写</div><div class="line">&#125;</div><div class="line">.<span class="title">addViewHold</span>(<span class="type">ViewHolder</span>)<span class="comment">//为default</span></div><div class="line">.<span class="title">addViewHold</span>(style,viewHolder)</div><div class="line">.<span class="title">addFooterHold</span>(<span class="type">ViewHolder</span>/resId)</div><div class="line">.<span class="title">addHeaderHold</span>(<span class="type">ViewHolder</span>/resId)</div><div class="line">.<span class="title">addEmptyHold</span>(<span class="type">ViewHolder</span>/resId)<span class="comment">//支持emptyHold</span></div><div class="line">.<span class="title">add</span>上啦<span class="title">Hold</span>(<span class="type">ViewHolder</span>)<span class="comment">//貌似应该放入 zrfresh的逻辑中.  ZRefresh loadMore可以和他联动？</span></div><div class="line">.<span class="title">notify</span>系列<span class="comment">//notify之间 自动计算动画？ 看看diffuitl工具</span></div><div class="line">.<span class="title">relaeList</span>(rv)</div></pre></td></tr></table></figure></p>
<p>ViewHolder<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ViewHolder</div><div class="line"><span class="keyword">public</span> itemView</div><div class="line"><span class="built_in">int</span> getLayoutId()</div><div class="line">update(postion,<span class="keyword">data</span> ,helper)</div></pre></td></tr></table></figure></p>
<h1 id="封装后的简单实用"><a href="#封装后的简单实用" class="headerlink" title="封装后的简单实用"></a>封装后的简单实用</h1><h2 id="QuickRcvAdapter范例"><a href="#QuickRcvAdapter范例" class="headerlink" title="QuickRcvAdapter范例"></a>QuickRcvAdapter范例</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">IAdapter&lt;String&gt; muliAdapter = <span class="keyword">new</span> QuickRcvAdapter(<span class="keyword">this</span>, mDatas)&#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">protected</span> <span class="function"><span class="keyword">int</span> <span class="title">getItemViewType2</span><span class="params">(<span class="keyword">int</span> dataPosition)</span> </span>&#123;</div><div class="line">               <span class="comment">//此方法可以默认 设置不写, 默认值返回Wrapper.DEFAULT_VALUE(-1)</span></div><div class="line">                   <span class="keyword">return</span> dataPosition % <span class="number">2</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           .addViewHolder(<span class="keyword">new</span> LeftDelegates())<span class="comment">//默认</span></div><div class="line">           .addViewHolder(<span class="number">0</span>, <span class="keyword">new</span> LeftDelegates()) <span class="comment">//多布局</span></div><div class="line">           .addViewHolder(<span class="number">1</span>, <span class="keyword">new</span> RightDelegates())<span class="comment">//多布局</span></div><div class="line">           .addHeaderHolder(R.layout.header_simple)<span class="comment">//资源</span></div><div class="line">           .addHeaderHolder(ViewDelegates footer)<span class="comment">//也可以的</span></div><div class="line">           .addFooterHolder(R.layout.footer_simple)<span class="comment">//资源</span></div><div class="line">           .addFooterHolder(ViewDelegates footer)<span class="comment">//也可以的</span></div><div class="line">           .addEmptyHold(R.layout.empty)<span class="comment">//也支持empty 资源</span></div><div class="line">           .addEmptyHold(ViewDelegates emtpy)<span class="comment">//也支持empty</span></div><div class="line">           .setOnItemClickListener(<span class="keyword">new</span> IAdapter.OnItemClickListener() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onItemClick</span><span class="params">(ViewGroup parent, View view, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                   System.out.println(<span class="string">"被点击-&gt;onItemClick"</span> + position);</div><div class="line">               &#125;</div><div class="line">           &#125;)</div><div class="line">           .setOnItemLongClickListener(<span class="keyword">new</span> IAdapter.OnItemLongClickListener() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onItemLongClick</span><span class="params">(ViewGroup parent, View view, <span class="keyword">int</span> position)</span> </span>&#123;</div><div class="line">                   System.out.println(<span class="string">"被点击-&gt;onItemLongClick:"</span> + position);</div><div class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;)</div><div class="line">           .addOnScrollListener(scroller = <span class="keyword">new</span> OnScrollRcvListenerEx(<span class="keyword">new</span> OnScrollRcvListenerEx.LoadMoreCallback() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">loadMore</span><span class="params">()</span> </span>&#123;</div><div class="line">               <span class="comment">//这个类主要是为了和我的ZRefresh库兼容。我会委托上啦加载在这里处理!</span></div><div class="line">               &#125;</div><div class="line">           &#125;))</div><div class="line">           .relatedList(rv)</div></pre></td></tr></table></figure>
<h2 id="ViewDelegates范例"><a href="#ViewDelegates范例" class="headerlink" title="ViewDelegates范例"></a>ViewDelegates范例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftDelegates</span> <span class="keyword">extends</span> <span class="title">ViewDelegates</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLayoutId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> R.layout.item_left;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fillData</span><span class="params">(<span class="keyword">int</span> postion, String data, Helper helper)</span> </span>&#123;</div><div class="line">        ExtraHelper.wrapper(helper).setText(R.id.tv, data).heihei().heihei2()</div><div class="line">                .setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">                        System.out.println(<span class="string">"helper click测试 "</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.id.tv, R.id.ll_main&#125;);</div><div class="line">        ;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Helper的扩展技巧-扩展技巧是-装饰模式-链式调用-泛型"><a href="#Helper的扩展技巧-扩展技巧是-装饰模式-链式调用-泛型" class="headerlink" title="Helper的扩展技巧:扩展技巧是 装饰模式+链式调用+泛型"></a>Helper的扩展技巧:扩展技巧是 装饰模式+链式调用+泛型</h2><blockquote>
<p>使用起来:ExtraHelper.wrapper(helper).setText(R.id.tv, data).heihei().heihei2();</p>
</blockquote>
<p>实现方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtraHelper</span> <span class="keyword">extends</span> <span class="title">Helper</span>&lt;<span class="title">ExtraHelper</span>&gt; </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExtraHelper</span><span class="params">(Helper helper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(helper.getContext(), helper.getHolder(),helper.getAdapter());</div><div class="line">        child = <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExtraHelper <span class="title">wrapper</span><span class="params">(Helper helper)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExtraHelper(helper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ExtraHelper <span class="title">heihei</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"heihei!"</span>);</div><div class="line">        checkChild();</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> ExtraHelper <span class="title">heihei2</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"heihei2!"</span>);</div><div class="line">        checkChild();</div><div class="line">        <span class="keyword">return</span> child;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><blockquote>
<p>新裤暂时就支持这点~<br>(原型模式-下拉刷新的全局设置)[<a href="https://luhaoaimama1.github.io/2017/04/04/Refresh/">https://luhaoaimama1.github.io/2017/04/04/Refresh/</a>]</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全局替换加载更多</span></div><div class="line"><span class="selector-tag">QuickConfig</span><span class="selector-class">.build</span>()<span class="selector-class">.setLoadMoreDelegates</span>(ILoadMoreDelegates iLoadMoreDelegates)<span class="selector-class">.perform</span>();</div></pre></td></tr></table></figure>
<h2 id="加载更多联动ZRefresh库"><a href="#加载更多联动ZRefresh库" class="headerlink" title="加载更多联动ZRefresh库"></a>加载更多联动ZRefresh库</h2><blockquote>
<p>其实是ZRefresh把加载更多的功能委托出去而已</p>
</blockquote>
<p><a href="https://github.com/luhaoaimama1/ZAdapter3/blob/master/app/src/main/java/zone/com/zadapter3/Recycler2ZRefreshActivity.java" target="_blank" rel="external">参考范例</a></p>
<h1 id="最后建议看看"><a href="#最后建议看看" class="headerlink" title="最后建议看看"></a>最后建议看看</h1><p>很美观一个库 <a href="https://github.com/GcsSloop/diycode" target="_blank" rel="external">https://github.com/GcsSloop/diycode</a></p>
<h2 id="看完Diycode的总结："><a href="#看完Diycode的总结：" class="headerlink" title="看完Diycode的总结："></a>看完Diycode的总结：</h2><ul>
<li><p>adapter重构(因为我原来写了adapter,看完这个库后推到重写adapter3)<br>headerFooterView功能<br>单独分离出一个类，既多类型复用。<br>数据并用helper定制图片加载等其他的逻辑<br>特点： 可复用，绑定数据</p>
</li>
<li><p>刷新控件与fragment的结合 ，布局结合 ？<br>这样有点耦合了  怎么才能 不耦合的处理？</p>
</li>
<li><p>刷新加载逻辑和网络请求 基类统一处理。  </p>
<blockquote>
<p><a href="https://github.com/luhaoaimama1/Http_Rflist_Helper" target="_blank" rel="external">有点类似我这个库,一直很少维护就是纠结啊,Ps:并且可以全局更换网络请求库</a></p>
</blockquote>
</li>
<li><p>给我以灵感:网络请求 是 通过请求 异步+eventbus？<br>这样多个注册了Subscribe的页面同时存活，其中一个请求。另一个页面也会处理相同的数据，会不会凌乱呢？</p>
<blockquote>
<p>不过这个确实很美观。我很喜欢 可以有一点缺憾,如果eventBus多支持一个方法,只在本类分发接受就好了~<br><img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff2vqpvwczj30eo07uwel.jpg" alt=""></p>
</blockquote>
</li>
<li><p>工具类<br>DataCache，FileUtil，DataCleanManager，UrlUtil，ACache，CacheUtil，UUIDGenerator<br>SpeedyLinearLayoutManager</p>
</li>
<li><p>灵感，不错的方法<br>public void setOnClickListener(View.OnClickListener l, int… ids)</p>
</li>
<li><p>复杂的书写格式<br><img src="https://ww1.sinaimg.cn/large/006tNc79gy1ff2wct9y99j30dc05gdg1.jpg" alt=""><br>非与或非的符号则用此格式</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">String </span>a,</div><div class="line"><span class="keyword">String </span><span class="keyword">b,</span></div><div class="line"><span class="keyword">String </span>c,</div><div class="line"><span class="keyword">String </span>d,</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="https://github.com/GcsSloop/diycode" target="_blank" rel="external">https://github.com/GcsSloop/diycode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分析时候的思路&quot;&gt;&lt;a href=&quot;#分析时候的思路&quot; class=&quot;headerlink&quot; title=&quot;分析时候的思路&quot;&gt;&lt;/a&gt;分析时候的思路&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;adapter里面的viewhold可以被复用&lt;blockquote&gt;
&lt;p&gt;所以需要重写一个方法通过位置获取layoutStyle，addviewHolder顺便传递一个layoutStyle,也可不传为默认值；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;layoutID要在viewhold的类方法中,而不是构造器中 &lt;blockquote&gt;
&lt;p&gt;  因为resID与viewHold本就是一个整体。方法构造中的话表示resID是可变的，并且看到这个viewhold类的时候布局文件看不到 容易蒙蔽&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;helper类与ButterKnife的取舍?&lt;blockquote&gt;
&lt;p&gt;helper比ButterKnife好,原因:可定制封装逻辑，不强转，可连写,可通过泛型+继承+装饰模式达到扩展的目的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;adapter 可扩展+链式调用  是用 泛型+继承 还是 同一个接口呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;泛型+继承 :在IDEA中是可以的。但是AS中出现了bug。我已经向google提意见了,估计不会吊我~&lt;br&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNc79gy1ff2v3z7mq0j31a20cewg6.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;所以退而求其次 选择同一个接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基础功能 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;addViewHold(ViewHolder)//为default&lt;br&gt;addViewHold(style,viewHolder)&lt;br&gt;addHeaderHold(ViewHolder/resId)&lt;br&gt;addFooterHold(ViewHolder/resId)&lt;br&gt;addEmptyHold(ViewHolder/resId)&lt;br&gt;notify系列&lt;br&gt;notifyEx系列(这里的位置对应为数据集的位置。包括header/footer)&lt;br&gt;relaeList(rv) 故事的开始。很多逻辑可以在这里完成  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="adapter" scheme="https://luhaoaimama1.github.io/tags/adapter/"/>
    
  </entry>
  
  <entry>
    <title>原型模式-下拉刷新的全局设置</title>
    <link href="https://luhaoaimama1.github.io/2017/04/04/Refresh/"/>
    <id>https://luhaoaimama1.github.io/2017/04/04/Refresh/</id>
    <published>2017-04-04T05:19:37.000Z</published>
    <updated>2017-04-04T07:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>全局替换刷新头部</p>
<p><code>头部可拔插</code>:需要应用策略模式(组合与接口的方式set get)；<br><code>全局替换</code>:就是原型模式 </p>
<blockquote>
<p>设置一个全局头部,那么每次使用的下拉刷新 都是全局头部的深拷贝对象。当然可以随意生成想要拷贝的特性；</p>
</blockquote>
<a id="more"></a>
<h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><p>头部接口<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHeaderView</span> &#123;</div><div class="line"></div><div class="line">    中间省略.....</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 全局更换头的配置</div><div class="line">     * 主要是为了复制头部对象，复制想要复制的属性</div><div class="line">     * 注意:返回null时候，默认就是新浪头了</div><div class="line">     */</div><div class="line">    <span class="function">IHeaderView <span class="title">clone_</span>(<span class="params"></span>)</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>全局设置<br><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="type">WaveHead</span> waveHead=<span class="function"><span class="keyword">new</span> <span class="title">WaveHead</span>();</span></div><div class="line"> <span class="title">waveHead</span>.<span class="title">setResourceId</span>(<span class="type">R</span>.drawable.aaaaaaaaaaaab);</div><div class="line"> <span class="title">Config</span>.<span class="title">build</span>()</div><div class="line">         .<span class="title">setHeader</span>(waveHead)</div><div class="line">         .<span class="title">setFooter</span>(new <span class="type">MeterialFooter</span>())</div><div class="line">         .<span class="title">setResistance</span>(new <span class="type">Damping2Head8per</span>())</div><div class="line">         .<span class="title">writeLog</span>(true)</div><div class="line">         .<span class="title">perform</span>();</div></pre></td></tr></table></figure></p>
<h1 id="实践项目："><a href="#实践项目：" class="headerlink" title="实践项目："></a>实践项目：</h1><p><a href="https://github.com/luhaoaimama1/ZRefreshLayout" target="_blank" rel="external">https://github.com/luhaoaimama1/ZRefreshLayout</a></p>
<blockquote>
<p>欢迎Star 自恋的宣传一下 (*&gt;∀&lt;)ﾉ))★</p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fbthspgg0qj31kw0xrdjz.jpg" alt=""></p>
<h1 id="特点与功能实现"><a href="#特点与功能实现" class="headerlink" title="特点与功能实现"></a>特点与功能实现</h1><ul>
<li>[x] 支持添加下拉刷新与上拉加载</li>
<li>[x] 支持所有的View:ImageView,FrameLayout,ListView, GridView, ScrollView, WebView…</li>
<li>[x] 全局配置(头部配置都在这里,所以没有xml属性~),与独立更改</li>
<li>[x] 自动刷新 延时刷新(如果刷新完毕有动画的话 需要用到延时刷新 ,<a href="https://github.com/luhaoaimama1/ZRefreshLayout/blob/master/app/src/main/java/zone/com/zrefreshlayoutdemo/header/CircleRefresh.java" target="_blank" rel="external">延时demo</a>)</li>
<li>[x] 头部是否固定</li>
<li>[x] 刷新出发位置</li>
<li>[x] 下拉位置映射，既resistance阻力</li>
<li>[x] 因为是继承FrameLayout,可以添加多个child。(我没有控制必须一个,感觉更灵活吧)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;目的&quot;&gt;&lt;a href=&quot;#目的&quot; class=&quot;headerlink&quot; title=&quot;目的&quot;&gt;&lt;/a&gt;目的&lt;/h1&gt;&lt;p&gt;全局替换刷新头部&lt;/p&gt;
&lt;p&gt;&lt;code&gt;头部可拔插&lt;/code&gt;:需要应用策略模式(组合与接口的方式set get)；&lt;br&gt;&lt;code&gt;全局替换&lt;/code&gt;:就是原型模式 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设置一个全局头部,那么每次使用的下拉刷新 都是全局头部的深拷贝对象。当然可以随意生成想要拷贝的特性；&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>图解解析ListView中的RecycleBin</title>
    <link href="https://luhaoaimama1.github.io/2017/03/16/RecycleBin/"/>
    <id>https://luhaoaimama1.github.io/2017/03/16/RecycleBin/</id>
    <published>2017-03-15T17:19:37.000Z</published>
    <updated>2017-03-16T02:26:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p><img src="https://ww2.sinaimg.cn/large/006tNc79gy1fdoguk5a9ij31fw1arn20.jpg" alt=""></p>
<a id="more"></a>
<p><a href="https://www.processon.com/view/link/58c96ccce4b0052bddd8107f" target="_blank" rel="external">图片项目地址 可以复制下来 进行修改</a></p>
<h1 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h1><p><a href="http://blog.csdn.net/iispring/article/details/50967445" target="_blank" rel="external">源码解析ListView中的RecycleBin机制文章</a></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://blog.csdn.net/iispring/article/details/50967445" target="_blank" rel="external">http://blog.csdn.net/iispring/article/details/50967445</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图解&quot;&gt;&lt;a href=&quot;#图解&quot; class=&quot;headerlink&quot; title=&quot;图解&quot;&gt;&lt;/a&gt;图解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ww2.sinaimg.cn/large/006tNc79gy1fdoguk5a9ij31fw1arn20.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/"/>
    
      <category term="RecycleBin" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/RecycleBin/"/>
    
    
      <category term="RecycleBin" scheme="https://luhaoaimama1.github.io/tags/RecycleBin/"/>
    
  </entry>
  
  <entry>
    <title>Handler、Looper、Message、MessageQueue基础流程分析图解</title>
    <link href="https://luhaoaimama1.github.io/2017/03/15/Handler%7CLooper%7CMessage%7CMessageQueue/"/>
    <id>https://luhaoaimama1.github.io/2017/03/15/Handler|Looper|Message|MessageQueue/</id>
    <published>2017-03-15T12:19:37.000Z</published>
    <updated>2017-03-16T02:26:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h1><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdnifh0enlj30to0phmxn.jpg" alt=""></p>
<a id="more"></a>
<p><a href="https://www.processon.com/view/link/58c8dffde4b01c1b4ab8b2ad" target="_blank" rel="external">图片项目地址 可以复制下来 进行修改</a></p>
<blockquote>
<p>ThreadLocal定义：不同线程存取　不会相互影响　而且用到的是一个变量！！<br>ThreadLocal：解释了为什么 线程里用的时候要prepare()和loop()<br>还有Activity创建的时候已经默认调用了prepare()与loop() 所以不需要你去弄.</p>
</blockquote>
<h1 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h1><p>老司机们都知道，Android的线程间通信就靠Handler、Looper、Message、MessageQueue这四个麻瓜兄弟了，那么，他们是怎么运作的呢？下面做一个基于主要源代码的大学生水平的分析。 <a href="http://anangryant.leanote.com/post/Handler%E3%80%81Looper%E3%80%81Message%E3%80%81MessageQueue%E5%88%86%E6%9E%90" target="_blank" rel="external">原文链接</a></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://anangryant.leanote.com/post/Handler%E3%80%81Looper%E3%80%81Message%E3%80%81MessageQueue%E5%88%86%E6%9E%90" target="_blank" rel="external">http://anangryant.leanote.com/post/Handler%E3%80%81Looper%E3%80%81Message%E3%80%81MessageQueue%E5%88%86%E6%9E%90</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图解&quot;&gt;&lt;a href=&quot;#图解&quot; class=&quot;headerlink&quot; title=&quot;图解&quot;&gt;&lt;/a&gt;图解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ww3.sinaimg.cn/large/006tKfTcgy1fdnifh0enlj30to0phmxn.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>了解Java中的I/O系统</title>
    <link href="https://luhaoaimama1.github.io/2017/03/14/IO/"/>
    <id>https://luhaoaimama1.github.io/2017/03/14/IO/</id>
    <published>2017-03-14T12:19:37.000Z</published>
    <updated>2017-03-16T02:25:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdmkir64xbj30xi0yrt9r.jpg" alt=""><br><a href="https://www.processon.com/view/link/58c7cef4e4b0337115d577a9" target="_blank" rel="external">图片项目地址 可以复制下来 进行修改</a></p>
<p><a href="https://github.com/luhaoaimama1/JavaZone/tree/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/io" target="_blank" rel="external">IO’s Demos Code</a></p>
<a id="more"></a>
<blockquote>
<p>编码乱码原因: 机器中的编码都是 二进制编码 显示的时候 为了让人看懂 从而设置了各种字符集 ,如果与原来的编码不一致则会导致看不懂既乱码 。机器的二进制码没有变化 ,仅仅是 对照的字符集 不一致 导致的</p>
</blockquote>
<h1 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h1><blockquote>
<p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p>
</blockquote>
<ul>
<li>读写单位不同<ul>
<li>字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li>
</ul>
</li>
<li>处理对象不同<ul>
<li>字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流 </li>
</ul>
</li>
</ul>
<blockquote>
<p>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</p>
</blockquote>
<h1 id="常用的处理流类型"><a href="#常用的处理流类型" class="headerlink" title="常用的处理流类型"></a>常用的处理流类型</h1><p>该类型是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写，处理流的构造方法总是要带一个其他流对象作为参数，一个流对象进过其他流的多次包装，叫做流的链接。主要可以分为以下几种：</p>
<h2 id="缓冲流（BufferedInPutStream-BufferedOutPutStream和BufferedWriter-BufferedReader）"><a href="#缓冲流（BufferedInPutStream-BufferedOutPutStream和BufferedWriter-BufferedReader）" class="headerlink" title="缓冲流（BufferedInPutStream/BufferedOutPutStream和BufferedWriter/BufferedReader）"></a>缓冲流（BufferedInPutStream/BufferedOutPutStream和BufferedWriter/BufferedReader）</h2><ul>
<li>功能<ul>
<li>提高对流的操作效率 </li>
<li>readLine()<br>一次读一行，到行标记时，将行标记之前的字符数据作为字符串返回，当读到末尾时，返回null，其原理还是与缓冲区关联的流对象的read方法，只不过每一次读取到一个字符，先不进行具体操作，先进行临时储存，当读取到回车标记时，将临时容器中储存的数据一次性返回。</li>
</ul>
</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">BufferedWriter bufw=<span class="keyword">new</span> <span class="type">BufferedWriter</span>(<span class="keyword">new</span> <span class="type">FileWriter</span>(<span class="string">"buf.txt"</span>));<span class="comment">//读取缓冲区对象：        </span></div><div class="line">BufferedReader bufr=<span class="keyword">new</span> <span class="type">BufferedReader</span>(<span class="keyword">new</span> <span class="type">FileReader</span>(<span class="string">"buf.txt"</span>));</div></pre></td></tr></table></figure>
<h2 id="转换流（InputStreamReader-OutputStreamWriter）"><a href="#转换流（InputStreamReader-OutputStreamWriter）" class="headerlink" title="转换流（InputStreamReader/OutputStreamWriter）"></a>转换流（InputStreamReader/OutputStreamWriter）</h2><p>该类型时字节流和字符流之间的桥梁，</p>
<ul>
<li>功能<ul>
<li>该类型时字节流和字符流之间的桥梁<br>该流对象中可以对读取到的字节数据进行指定编码的编码转换。</li>
</ul>
</li>
</ul>
<p>构造函数主要有：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">InputStreamReader</span>(InputStream);        <span class="comment">//通过构造函数初始化，使用的是本系统默认的编码表GBK。  </span></div><div class="line"><span class="selector-tag">InputStreamWriter</span>(InputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。  </span></div><div class="line"><span class="selector-tag">OutputStreamWriter</span>(OutputStream);      <span class="comment">//通过该构造函数初始化，使用的是本系统默认的编码表GBK。  </span></div><div class="line"><span class="selector-tag">OutputStreamwriter</span>(OutputStream,String charSet);   <span class="comment">//通过该构造函数初始化，可以指定编码表。</span></div></pre></td></tr></table></figure></p>
<p>这里看下 FileReader类的构造器 </p>
<ul>
<li>相当于 new InputStreamReader(new FileInputStream(“a.txt”))</li>
<li>并且该对象使用的时默认的编码表<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FileReader</span> <span class="keyword">extends</span> <span class="title">InputStreamReader</span> </span>&#123;</div><div class="line"> public <span class="type">FileReader</span>(<span class="type">String</span> fileName) <span class="keyword">throws</span> <span class="type">FileNotFoundException</span> &#123;</div><div class="line">        <span class="comment">//相当于 new InputStreamReader(new FileInputStream("a.txt"));</span></div><div class="line">        <span class="keyword">super</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(fileName));<span class="comment">//该对象使用的时默认的编码表</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>即如果a.txt中的文件中的字符数据是通过utf-8的形式编码，那么在读取时，就必须指定编码表，那么转换流时必须的。即：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InputStreamReader isr=<span class="keyword">new</span> <span class="type">InputStreamReader</span>(<span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">"a.txt"</span>),utf<span class="number">-8</span>);</div></pre></td></tr></table></figure>
<h2 id="数据流（DataInputStream-DataOutputStream）"><a href="#数据流（DataInputStream-DataOutputStream）" class="headerlink" title="数据流（DataInputStream/DataOutputStream）"></a>数据流（DataInputStream/DataOutputStream）</h2><p>该数据流可以方便地对一些基本类型数据进行直接的存储和读取，不需要再进一步进行转换，通常只要操作基本数据类型的数据，就需要通过DataStream进行包装。</p>
<p>构造方法：        </p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DataInputStreamReader（<span class="keyword">InputStream</span>）；  </div><div class="line"> DataInputStreamWriter（<span class="keyword">OutputStream</span>）</div></pre></td></tr></table></figure>
<p>方法举例：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">int</span> <span class="selector-tag">readInt</span>()；<span class="comment">//一次读取四个字节，并将其转成int值  </span></div><div class="line"><span class="selector-tag">writeInt</span>(int)；<span class="comment">//一次写入四个字节，注意和write(int)不同，write(int)只将该整数的最低一个8位写入，剩余三个8为丢失  </span></div><div class="line"><span class="selector-tag">hort</span> <span class="selector-tag">readShort</span>();  </div><div class="line"><span class="selector-tag">writeShort</span>(short);  </div><div class="line"><span class="selector-tag">String</span> <span class="selector-tag">readUTF</span>();<span class="comment">//按照utf-8修改版读取字符，注意，它只能读writeUTF()写入的字符数据。  </span></div><div class="line"><span class="selector-tag">writeUTF</span>(String);<span class="comment">//按照utf-8修改版将字符数据进行存储，只能通过readUTF读取。 </span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>注意：在使用数据流读/存数据的时候，需要有一定的顺序，即某个类型的数据先写入就必须先读出，服从先进先出的原则。</p>
<h2 id="打印流（PrintStream-PrintWriter）"><a href="#打印流（PrintStream-PrintWriter）" class="headerlink" title="打印流（PrintStream/PrintWriter）"></a>打印流（PrintStream/PrintWriter）</h2><p>PrintStream是一个字节打印流，System.out对应的类型就是PrintStream</p>
<ul>
<li>它的构造函数可以接受数据类型：<ul>
<li>字符串路径</li>
<li>File对象 </li>
<li>OutputStream</li>
</ul>
</li>
</ul>
<p>PrintStream是一个字符打印流</p>
<ul>
<li>它的构造函数可以接受数据类型：<ul>
<li>字符串路径</li>
<li>File对象</li>
<li>OutputStream  </li>
<li>Writer </li>
</ul>
</li>
</ul>
<p>对于1、2类型的数据，可以指定编码表，也就是字符集，对于3、4类型的数据，可以指定自动刷新，当该自动刷新为True时，只有3个方法可以用：println,printf,format。 </p>
<h2 id="对象流（ObjectInputStream-ObjectOutputStream）"><a href="#对象流（ObjectInputStream-ObjectOutputStream）" class="headerlink" title="对象流（ObjectInputStream/ObjectOutputStream）"></a>对象流（ObjectInputStream/ObjectOutputStream）</h2><p>该类型的流可以把类作为一个整体进行存取，主要方法有：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span> readObject();该方法抛出异常：ClassNotFountException。</div><div class="line"></div><div class="line"><span class="keyword">void</span> writeObject(<span class="built_in">Object</span>)：被写入的对象必须实现一个接口：Serializable，否则就会抛出：NotSerializableException</div></pre></td></tr></table></figure></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://blog.csdn.net/zzp_403184692/article/details/8057693" target="_blank" rel="external">http://blog.csdn.net/zzp_403184692/article/details/8057693</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tKfTcgy1fdmkir64xbj30xi0yrt9r.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://www.processon.com/view/link/58c7cef4e4b0337115d577a9&quot;&gt;图片项目地址 可以复制下来 进行修改&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luhaoaimama1/JavaZone/tree/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/io&quot;&gt;IO’s Demos Code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/"/>
    
      <category term="I/O" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/I-O/"/>
    
    
      <category term="I/O" scheme="https://luhaoaimama1.github.io/tags/I-O/"/>
    
  </entry>
  
  <entry>
    <title>常用排序图解</title>
    <link href="https://luhaoaimama1.github.io/2017/03/14/%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3/"/>
    <id>https://luhaoaimama1.github.io/2017/03/14/排序图解/</id>
    <published>2017-03-14T05:19:37.000Z</published>
    <updated>2017-03-14T07:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdmd05t9trj30ex06274e.jpg" alt=""></p>
<p><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
<a id="more"></a>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdmd0inhvbj30u30gr0u2.jpg" alt=""><br><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdmd0ero4aj308n064q43.jpg" alt=""><br><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdmd0n73syj30fl0emjs8.jpg" alt=""><br><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>如图多次 分组循环即可  最后  都会分成 一个的。<br><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdmd0qf7axj30fo067ju4.jpg" alt=""></p>
<p>切分元素 为美组第一个。    小于左边 ，大于右边  的转换过程为此图<br><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdmd0tsfwjj31ea0smwfw.jpg" alt=""></p>
<p><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
<h2 id="二分查找（折半插入查找）"><a href="#二分查找（折半插入查找）" class="headerlink" title="二分查找（折半插入查找）"></a>二分查找（折半插入查找）</h2><p>这个是 while 一半的 二分方式 定位 应该放的位置。然后后边的统一向后移动。<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdmdwbpbrij31kw0ob0tp.jpg" alt=""></p>
<p><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F.java" target="_blank" rel="external">查看Code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://ww1.sinaimg.cn/large/006tKfTcgy1fdmd05t9trj30ex06274e.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/a%E9%9D%A2%E8%AF%95/%E6%8E%92%E5%BA%8F/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.java&quot;&gt;查看Code&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="排序" scheme="https://luhaoaimama1.github.io/categories/%E6%8E%92%E5%BA%8F/"/>
    
    
      <category term="排序" scheme="https://luhaoaimama1.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android-2017面试题整理(未整理完)</title>
    <link href="https://luhaoaimama1.github.io/2017/02/09/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://luhaoaimama1.github.io/2017/02/09/面试题/</id>
    <published>2017-02-09T05:19:37.000Z</published>
    <updated>2017-02-08T08:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>2017面试题整理</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="Activity的生命周期的理解"><a href="#Activity的生命周期的理解" class="headerlink" title="Activity的生命周期的理解"></a>Activity的生命周期的理解</h2><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fchvt46g5aj30fx0kbwf0.jpg" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">周期</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onCreate()</td>
<td style="text-align:center">【创建基本的UI元素】：当 activity 第一次创建时会被调用。</td>
</tr>
<tr>
<td style="text-align:center">onRestart()</td>
<td style="text-align:center">在 activity 被停止后重新启动时会调用该方法。其后续会调用 onStart 方法。</td>
</tr>
<tr>
<td style="text-align:center">onStart()</td>
<td style="text-align:center">交互之前 不可见，位图从新加载；</td>
</tr>
<tr>
<td style="text-align:center">onResume()</td>
<td style="text-align:center">【从新初始化资源 例如Camera、sensor】：交互之前 可见不可操作</td>
</tr>
<tr>
<td style="text-align:center">onPause()</td>
<td style="text-align:center">【清除资源 避免浪费  例如Camera、sensor】：交互之后 可见 不可操作</td>
</tr>
<tr>
<td style="text-align:center">onStop()</td>
<td style="text-align:center">交互之后  不可见，位图回收 不可再pause回收那样会造成 正在使用已经回收的位图错误;</td>
</tr>
<tr>
<td style="text-align:center">onDestroy()</td>
<td style="text-align:center">【因为引用会在Activity销毁的时候销毁，而线程不会，所以清楚开启的线程】：在 activity 被销毁前会调用该方法</td>
</tr>
<tr>
<td style="text-align:center">onWindowFocusChanged(boolean hasFocus)</td>
<td style="text-align:center">hasFocus true就是可见，false就是不可见；官方意思:这个Activity得到或者失去焦点的时候 就会call。</td>
</tr>
</tbody>
</table>
<ul>
<li>扩展<blockquote>
<p>今天又听说有同学遭遇了更变态的问题：什么情况下Activity走了onCreat()，而不走onStart()，这简直就是脑筋急转弯嘛。<br>是在onCeate里面，调用finish直接就挂掉不会调用onStart了</p>
</blockquote>
</li>
</ul>
<h2 id="service生命周期？"><a href="#service生命周期？" class="headerlink" title="service生命周期？"></a>service生命周期？</h2><p>这里要注意service有两种启动方式，startService()和bindService()<br><img src="http://upload-images.jianshu.io/upload_images/1187237-4cbfd0f464cd5313.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="如何理解Activity，View，Window三者之间的关系？"><a href="#如何理解Activity，View，Window三者之间的关系？" class="headerlink" title="如何理解Activity，View，Window三者之间的关系？"></a>如何理解Activity，View，Window三者之间的关系？</h2><ul>
<li>Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。</li>
<li>这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。</li>
<li>“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等</li>
<li>这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。</li>
</ul>
<h2 id="Activity的几种LaunchMode"><a href="#Activity的几种LaunchMode" class="headerlink" title="Activity的几种LaunchMode"></a>Activity的几种LaunchMode</h2><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk3mqtd_1vOQt92MTTz53ktcy1" target="_blank" rel="external">http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk3mqtd_1vOQt92MTTz53ktcy1</a></p>
<h2 id="横竖屏切换时候activity的生命周期"><a href="#横竖屏切换时候activity的生命周期" class="headerlink" title="横竖屏切换时候activity的生命周期"></a>横竖屏切换时候activity的生命周期</h2><ul>
<li>设置 android:configChanges=”orientation” 和不设置这个属性，生命周期表现为重新创建activity</li>
<li>设置 android:configChanges=”orientation|keyboardHidden”，在2.3上表现为不重新创建activity，4.0如下<ul>
<li>android:targetSdkVersion&lt;=”12”，生命周期表现为不重新创建activity</li>
<li>android:targetSdkVersion&gt;”12”，表现为重新创建activity</li>
</ul>
</li>
<li>设置 android:configChanges=”orientation|keyboardHidden|screenSize”，在2.3和4.0上都表现为不重新创建<br>版本不一样切竖屏执行的次数不一样，而且configChanges在3.2之后需要配置screenSize<br>参考:<a href="http://www.cnblogs.com/xiaoQLu/p/3324503.html" target="_blank" rel="external">http://www.cnblogs.com/xiaoQLu/p/3324503.html</a></li>
</ul>
<h2 id="android中的动画有哪几类，它们的特点和区别是什么"><a href="#android中的动画有哪几类，它们的特点和区别是什么" class="headerlink" title="android中的动画有哪几类，它们的特点和区别是什么?"></a>android中的动画有哪几类，它们的特点和区别是什么?</h2><ul>
<li>FrameAnimation（逐帧动画）：将多张图片组合起来进行播放，类似于早期电影的工作原理，很多App的loading是采用这种方式。</li>
<li>TweenAnimation（补间动画）：是对某个View进行一系列的动画的操作，包括淡入淡出（Alpha），缩放（Scale），平移（Translate），旋转（Rotate）四种模式。</li>
<li>PropertyAnimation（属性动画）：属性动画不再仅仅是一种视觉效果了，而是一种不断地对值进行操作的机制，并将值赋到指定对象的指定属性上，可以是任意对象的任意属性。</li>
</ul>
<h2 id="handler机制的原理"><a href="#handler机制的原理" class="headerlink" title="handler机制的原理"></a>handler机制的原理</h2><p>andriod提供了 Handler 和 Looper 来满足线程间的通信。Handler 先进先出原则。Looper类用来管理特定线程内对象之间的消息交换(Message Exchange)。</p>
<ul>
<li>Looper: 一个线程可以产生一个Looper对象，由它来管理此线程里的Message Queue(消息队列)。</li>
<li>Handler: 你可以构造Handler对象来与Looper沟通，以便push新消息到Message Queue里;或者接收Looper从Message Queue取出)所送来的消息。</li>
<li>Message Queue(消息队列):用来存放线程放入的消息。</li>
<li>线程：UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。</li>
</ul>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1fchwjv65jhj30sg0fgjtw.jpg" alt=""><br>需要注意的地方：</p>
<ul>
<li>prepareMainLooper ：为ActivityThread特殊准备的</li>
<li>handler对象只能添加到有消息队列的线程中 否则会发生异常 其实Activity被构造前已经.prepare了 而且不能.prepare两次</li>
<li>一个线程可以有多个handler  每个 message会对应对应 的handler（监听在handler内部）  所以没事</li>
<li>Looper也是可以退出的 如果所有的事情都完事了 可以quit不然,looper会一直等待下去(当然可以不管~)</li>
<li>quit :直接退出</li>
<li>quitSafely:先设定一个退出标识（小心进不来了），然后把消息处理完后真正退出</li>
<li>Activity的主线程就是ActivityThread 主线程的入口是main方法</li>
</ul>
<h2 id="让Activity变成一个窗口：Activity属性设定"><a href="#让Activity变成一个窗口：Activity属性设定" class="headerlink" title="让Activity变成一个窗口：Activity属性设定"></a>让Activity变成一个窗口：Activity属性设定</h2><p>对话框<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">android</span> :theme=<span class="string">"<span class="variable">@android</span>:style/Theme.Dialog"</span></div></pre></td></tr></table></figure></p>
<p>半透明的</p>
<blockquote>
<p>注意其生命周期</p>
</blockquote>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">android:</span>theme=<span class="string">"@android:style/Theme.Translucent"</span></div></pre></td></tr></table></figure>
<h2 id="如何将SQLite数据库-dictionary-db文件-与apk文件一起发布"><a href="#如何将SQLite数据库-dictionary-db文件-与apk文件一起发布" class="headerlink" title="如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?"></a>如何将SQLite数据库(dictionary.db文件)与apk文件一起发布?</h2><p>可以将dictionary.db文件复制到Eclipse Android工程中的res raw目录中。所有在res raw目录中的文件不会被压缩，这样可以直接提取该目录中的文件。可以将dictionary.db文件复制到res raw目录中</p>
<h2 id="如何将打开res-raw目录中的数据库文件"><a href="#如何将打开res-raw目录中的数据库文件" class="headerlink" title="如何将打开res raw目录中的数据库文件?"></a>如何将打开res raw目录中的数据库文件?</h2><p>在Android中不能直接打开res raw目录中的数据库文件，而需要在程序第一次启动时将该文件复制到手机内存或SD卡的某个目录中，然后再打开该数据库文件。复制的基本方法是使用getResources().openRawResource方法获得res raw目录中资源的 InputStream对象，然后将该InputStream对象中的数据写入其他的目录中相应文件中。在Android SDK中可以使用SQLiteDatabase.openOrCreateDatabase方法来打开任意目录中的SQLite数据库文件。  </p>
<h2 id="MVC-MVVM-MVP"><a href="#MVC-MVVM-MVP" class="headerlink" title="MVC MVVM  MVP"></a>MVC MVVM  MVP</h2><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk03i2dZ3qEkEB2hONOQ1uxi1j" target="_blank" rel="external">http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk03i2dZ3qEkEB2hONOQ1uxi1j</a></p>
<h2 id="什么是ANR-如何避免它"><a href="#什么是ANR-如何避免它" class="headerlink" title="什么是ANR 如何避免它?"></a>什么是ANR 如何避免它?</h2><p>ANR：Application Not Responding。</p>
<ul>
<li>用户对应用程序的操作(如输入事件，按键、触摸屏事件)在5秒内无响应</li>
<li>广播接受器(BroadcastReceiver)在10秒内仍未执行完毕 </li>
</ul>
<blockquote>
<p>不要在UI线程做耗时操作即可避免</p>
</blockquote>
<h2 id="如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态"><a href="#如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态" class="headerlink" title="如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态?"></a>如果后台的Activity由于某原因被系统回收了，如何在被系统回收之前保存当前状态?</h2><p>通过重写onSaveInstanceState（）方法来实现Activity的运行状态，请注意以下几点：</p>
<ul>
<li>由于activity 对象被暂停或停止时，它仍然保留在内存里面，关于它的成员信息和当前状态都是活动的，所以此时可以保存Activity的状态，从而使用户所作的Activity的更改保存在内存中</li>
<li>当系统回收内存而将Activity销毁时，就无法保存其状态，所以需要调用onSaveInstanceState（）方法来实现状态的保存</li>
<li>很多情况并不需要保持状态信息，比如按下返回键直接关闭程序，所以并不能保证会调用onSaveInstanceState。如果调用了该方法，一般是在onStop 方法之前且可能在 onPause 之后调用。尽管如此，即使你没做任何操作或没有实现 onSaveInstanceState() 方法，你的 activity 状态也能通过Activity 类里面默认实现的 onSaveInstanceState 方法恢复出来。特别是会为布局中的视图（ View ）默认调用onSaveInstanceState 方法，并在这个方法中允许每一个视图提供它需要恢复的任何信息。几乎每一个 Android框架中的 widget 都视情况实现了这个方法。</li>
</ul>
<p>注：因为 onSaveInstanceState 方法不一定会被调用(系统因为内存紧张回收的时候才调用 或者调整Activity的方向把)，所以你应该只是用它来保存一些 activity 的转换过程状态（即 UI 的状态），而不能用来保存永久性数据。但你可以用 onPause 方法在用户离开 activity 时来保存永久性数据，比如需要保存到数据库的数据。<br>有一个很好的方法可以用来检验应用程序保存状态的能力，就是简单地旋转你的设备来改变屏幕的方向。因为当屏幕方向改变时，系统为了给新的方向提供一个可能合适的代替资源，会销毁 activity 并新建一个新的。由于这个原因，你的 activity 是否能在其重新创建时完成保存状态就显得尤为重要，因为用户经常会在使用应用程序时旋转屏幕的。<br>上文部分内容参考了：<a href="http://blog.csdn.net/sam_zhang1984/article/details/6430817" target="_blank" rel="external">http://blog.csdn.net/sam_zhang1984/article/details/6430817</a></p>
<h2 id="谈谈android数据存储方式。"><a href="#谈谈android数据存储方式。" class="headerlink" title="谈谈android数据存储方式。"></a>谈谈android数据存储方式。</h2><p>Android提供了5种方式存储数据：</p>
<ul>
<li>使用SharedPreferences存储数据；它是Android提供的用来存储一些简单配置信息的一种机制，采用了XML格式将数据存储到设备中。只能在同一个包内使用，不能在不同的包之间使用。</li>
<li>文件存储数据；文件存储方式是一种较常用的方法，在Android中读取/写入文件的方法，与Java中实现I/O的程序是完全一样的，提供了openFileInput()和openFileOutput()方法来读取设备上的文件。</li>
<li>SQLite数据库存储数据；SQLite是Android所带的一个标准的数据库，它支持SQL语句，它是一个轻量级的嵌入式数据库。</li>
<li>使用ContentProvider存储数据；主要用于应用程序之间进行数据交换，从而能够让其他的应用保存或读取此Content Provider的各种数据类型。</li>
<li>网络存储数据；通过网络上提供给我们的存储空间来上传(存储)和下载(获取)我们存储在网络空间中的数据信息。</li>
</ul>
<h2 id="Android中Activity-Intent-Content-Provider-Service各有什么区别。"><a href="#Android中Activity-Intent-Content-Provider-Service各有什么区别。" class="headerlink" title="Android中Activity, Intent, Content Provider, Service各有什么区别。"></a>Android中Activity, Intent, Content Provider, Service各有什么区别。</h2><ul>
<li>Activity： 活动，是最基本的android应用程序组件。一个活动就是一个用户可以操作的可视化用户界面，每一个活动都被实现为一个独立的类，并且从活动基类继承而来。</li>
<li>Intent： 意图，描述应用想干什么。最重要的部分是动作和动作对应的数据。</li>
<li>Content Provider：内容提供器，android应用程序能够将它们的数据保存到文件、SQLite数据库中，甚至是任何有效的设备中。当你想将你的应用数据和其他应用共享时，内容提供器就可以发挥作用了。</li>
<li>Service：服务，具有一段较长生命周期且没有用户界面的程序组件。</li>
</ul>
<h2 id="View-surfaceView-GLSurfaceView有什么区别。"><a href="#View-surfaceView-GLSurfaceView有什么区别。" class="headerlink" title="View, surfaceView, GLSurfaceView有什么区别。"></a>View, surfaceView, GLSurfaceView有什么区别。</h2><ul>
<li>view是最基础的，必须在UI主线程内更新画面，速度较慢。</li>
<li>SurfaceView 是view的子类，类似使用双缓机制，在新的线程中更新画面所以刷新界面速度比view快</li>
<li>GLSurfaceView 是SurfaceView的子类，opengl 专用的</li>
</ul>
<h2 id="Manifest-xml文件中主要包括哪些信息？"><a href="#Manifest-xml文件中主要包括哪些信息？" class="headerlink" title="Manifest.xml文件中主要包括哪些信息？"></a>Manifest.xml文件中主要包括哪些信息？</h2><ul>
<li>manifest：根节点，描述了package中所有的内容。</li>
<li>uses-permission：请求你的package正常运作所需赋予的安全许可。</li>
<li>permission： 声明了安全许可来限制哪些程序能你package中的组件和功能。</li>
<li>instrumentation：声明了用来测试此package或其他package指令组件的代码。</li>
<li>application：包含package中application级别组件声明的根节点。</li>
<li>activity：Activity是用来与用户交互的主要工具。</li>
<li>receiver：IntentReceiver能使的application获得数据的改变或者发生的操作，即使它当前不在运行。</li>
<li>service：Service是能在后台运行任意时间的组件。</li>
<li>provider：ContentProvider是用来管理持久化数据并发布给其他应用程序使用的组件。</li>
</ul>
<h2 id="根据自己的理解描述下Android数字签名"><a href="#根据自己的理解描述下Android数字签名" class="headerlink" title="根据自己的理解描述下Android数字签名"></a>根据自己的理解描述下Android数字签名</h2><ul>
<li>所有的应用程序都必须有数字证书，Android系统不会安装一个没有数字证书的应用程序</li>
<li>Android程序包使用的数字证书可以是自签名的，不需要一个权威的数字证书机构签名认证</li>
<li>如果要正式发布一个Android程序，必须使用一个合适的私钥生成的数字证书来给程序签名，而不能使用adt插件或者ant工具生成的调试证书来发布。</li>
<li>数字证书都是有有效期的，Android只是在应用程序安装的时候才会检查证书的有效期。如果程序已经安装在系统中，即使证书过期也不会影响程序的正常功能。* </li>
</ul>
<h2 id="android-gravity与android-layout-gravity的区别"><a href="#android-gravity与android-layout-gravity的区别" class="headerlink" title="android:gravity与android:layout_gravity的区别"></a>android:gravity与android:layout_gravity的区别</h2><ul>
<li>android:gravity用于设置View组件的对齐方式</li>
<li>android:layout_gravity用于设置Container组件的 对齐方式。</li>
</ul>
<h2 id="注册广播接收者两种方式的区别，及优缺点"><a href="#注册广播接收者两种方式的区别，及优缺点" class="headerlink" title="注册广播接收者两种方式的区别，及优缺点"></a>注册广播接收者两种方式的区别，及优缺点</h2><p>注册的方法有两种，一种是静态注册:清单文件中声明，一种是动态注册:代码进行注册。<br>动态注册优点(跟随程序的生命周期)：在 Android 的广播机制中，动态注册的优先级是要高于静态注册优先级的，因此在必要的情况下，我们是需要动态注册广播接收器的。<br>静态注册优点(手机开着即可)：动态注册广播接收器还有一个特点，就是当用来注册的 Activity 关掉后，广播也就失效了。同时反映了静态注册的一个优势，就是无需担忧广播接收器是否被关闭，只要设备是开启状态，广播接收器就是打开着的。</p>
<h2 id="android中有哪几种解析xml的类-官方推荐哪种？以及它们的原理和区别"><a href="#android中有哪几种解析xml的类-官方推荐哪种？以及它们的原理和区别" class="headerlink" title="android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别"></a>android中有哪几种解析xml的类,官方推荐哪种？以及它们的原理和区别</h2><ul>
<li>DOM:加载内存 生成一个树状结构,消耗内存大</li>
<li>SAM:基于事件的方式,速度快,效率高 不能倒退</li>
<li>PULL:解析器的运行方式和SAX类似，都是基于事件的模式,区别我们需要自己获取产生的事件然后做相应的操作，而不像SAX那样由处理器触发一种事件的方法，执行我们的代码小巧轻便，非常适合在Android移动设备中使用，Android系统内部在解析各种XML时也是用PULL解析器。</li>
</ul>
<blockquote>
<p>pull比sax更简明,而且不需要扫描完整个流.</p>
</blockquote>
<h2 id="双缓冲技术原理以及优缺点："><a href="#双缓冲技术原理以及优缺点：" class="headerlink" title="双缓冲技术原理以及优缺点："></a>双缓冲技术原理以及优缺点：</h2><p>创建一幅后台图像，将每一帧画入图像，然后调用drawImage()方法将整个后台图像一次画到屏幕上去。<br>优点：双缓冲技术的优点在于大部分绘制是离屏的。<br>            将离屏图像一次绘至屏幕上，比直接在屏幕上绘制要有效得多。<br>            双缓冲技术可以使动画平滑。<br>缺点：要分配一个后台图像的缓冲，如果图像相当大，这将占用很大一块内存。</p>
<h2 id="GridView-ListView出现的问题"><a href="#GridView-ListView出现的问题" class="headerlink" title="GridView 　ListView出现的问题"></a>GridView 　ListView出现的问题</h2><ul>
<li><p>ListView的吨卡现象</p>
<ul>
<li>getView中　耗时操作了</li>
<li>view复用</li>
<li>优化布局  清理布局中不用的 view  尽量减少</li>
<li>列表滑动的时候停止夹在图片　</li>
<li>启用硬件加速</li>
</ul>
</li>
<li><p>图片错位</p>
<ul>
<li>图片先加载了这个任务然后快速滑动　　此控件又被复用了　然后又加载另一个图片<br>解决方法：　完成时判断view的url和任务url是否相同然后决定是否加载</li>
</ul>
</li>
</ul>
<h2 id="Touch事件的传递机制"><a href="#Touch事件的传递机制" class="headerlink" title="Touch事件的传递机制"></a>Touch事件的传递机制</h2><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1fchzqo0yjij30qt0hrmy2.jpg" alt=""></p>
<blockquote>
<p>Activity－＞Window－＞View 如果所有人都不消耗最后会在activity中的onTouchEvent上处理<br>执行顺序:onTouchListener &gt; onTouchEvent &gt; onLongClickListener &gt; onClickListener</p>
</blockquote>
<h2 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h2><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk2v4H3m2F5QkL2AMzrJ2dUJlA" target="_blank" rel="external">http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk2v4H3m2F5QkL2AMzrJ2dUJlA</a></p>
<h2 id="在View比较重要的回调方法"><a href="#在View比较重要的回调方法" class="headerlink" title="在View比较重要的回调方法"></a>在View比较重要的回调方法</h2><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk1s1fj02XCkI92r2-813nZxDP" target="_blank" rel="external">http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk1s1fj02XCkI92r2-813nZxDP</a></p>
<h2 id="View生命周期的官方文档"><a href="#View生命周期的官方文档" class="headerlink" title="View生命周期的官方文档"></a>View生命周期的官方文档</h2><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk0aznMy2WZ4bz26V5Sj17kjFI" target="_blank" rel="external">http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk0aznMy2WZ4bz26V5Sj17kjFI</a></p>
<h2 id="设计一套图片异步加载缓存方案"><a href="#设计一套图片异步加载缓存方案" class="headerlink" title="设计一套图片异步加载缓存方案"></a>设计一套图片异步加载缓存方案</h2><p><a href="http://blog.csdn.net/boyupeng/article/details/47127605" target="_blank" rel="external">http://blog.csdn.net/boyupeng/article/details/47127605</a></p>
<h2 id="Fragment的那些坑"><a href="#Fragment的那些坑" class="headerlink" title="Fragment的那些坑"></a>Fragment的那些坑</h2><p><a href="http://www.jianshu.com/p/d9143a92ad94" target="_blank" rel="external">http://www.jianshu.com/p/d9143a92ad94</a><br><a href="http://www.jianshu.com/p/fd71d65f0ec6" target="_blank" rel="external">http://www.jianshu.com/p/fd71d65f0ec6</a><br><a href="http://www.jianshu.com/p/38f7994faa6b" target="_blank" rel="external">http://www.jianshu.com/p/38f7994faa6b</a></p>
<h2 id="Http-Https"><a href="#Http-Https" class="headerlink" title="Http Https"></a>Http Https</h2><p><a href="http://www.jianshu.com/p/93fdebe5fef1" target="_blank" rel="external">http://www.jianshu.com/p/93fdebe5fef1</a></p>
<h2 id="网络请求优化"><a href="#网络请求优化" class="headerlink" title="网络请求优化"></a>网络请求优化</h2><p><a href="http://www.jianshu.com/p/3141d4e46240" target="_blank" rel="external">http://www.jianshu.com/p/3141d4e46240</a></p>
<h2 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h2><p><a href="http://www.jianshu.com/p/5bb8c01e2bc7" target="_blank" rel="external">http://www.jianshu.com/p/5bb8c01e2bc7</a></p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p><a href="http://www.jianshu.com/p/a956024629cb" target="_blank" rel="external">http://www.jianshu.com/p/a956024629cb</a></p>
<h1 id="额外的了解"><a href="#额外的了解" class="headerlink" title="额外的了解"></a>额外的了解</h1><h2 id="一条最长的短信息约占多少byte"><a href="#一条最长的短信息约占多少byte" class="headerlink" title="一条最长的短信息约占多少byte?"></a>一条最长的短信息约占多少byte?</h2><p>中文70(包括标点)，英文160个字节。</p>
<h2 id="什么是嵌入式实时操作系统-Android-操作系统属于实时操作系统吗"><a href="#什么是嵌入式实时操作系统-Android-操作系统属于实时操作系统吗" class="headerlink" title="什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?"></a>什么是嵌入式实时操作系统, Android 操作系统属于实时操作系统吗?</h2><p>嵌入式实时操作系统是指当外界事件或数据产生时，能够接受并以足够快的速度予以处理，其处理的结果又能在规定的时间之内来控制生产过程或对处理系统作出快速响应，并控制所有实时任务协调一致运行的嵌入式操作系统。主要用于工业控制、 军事设备、 航空航天等领域对系统的响应时间有苛刻的要求，这就需要使用实时系统。又可分为软实时和硬实时两种，而android是基于Linux内核的，因此属于软实时</p>
<h2 id="android中线程与线程，进程与进程之间如何通信"><a href="#android中线程与线程，进程与进程之间如何通信" class="headerlink" title="android中线程与线程，进程与进程之间如何通信"></a>android中线程与线程，进程与进程之间如何通信</h2><p>binder跨进程 handler跨线程。主要是防止耗时线程阻塞UI线程;   </p>
<h2 id="Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念"><a href="#Android-dvm的进程和Linux的进程-应用程序的进程是否为同一个概念" class="headerlink" title="Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念"></a>Android dvm的进程和Linux的进程, 应用程序的进程是否为同一个概念</h2><p>DVM指dalivk的虚拟机。每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例。而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念</p>
<h2 id="sim卡的EF-文件有何作用"><a href="#sim卡的EF-文件有何作用" class="headerlink" title="sim卡的EF 文件有何作用"></a>sim卡的EF 文件有何作用</h2><p>sim卡的文件系统有自己规范，主要是为了和手机通讯，sim本 身可以有自己的操作系统，EF就是作存储并和手机通讯用的</p>
<h1 id="收集的面试-非本人"><a href="#收集的面试-非本人" class="headerlink" title="收集的面试(非本人)"></a>收集的面试(非本人)</h1><p><a href="http://www.jianshu.com/p/dc8ce6db2f6f" target="_blank" rel="external">蘑菇街内推Android面试</a></p>
<h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1><h2 id="热修复的原理"><a href="#热修复的原理" class="headerlink" title="热修复的原理"></a>热修复的原理</h2><h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://www.jianshu.com/p/a22450882af2" target="_blank" rel="external">http://www.jianshu.com/p/a22450882af2</a><br><a href="http://blog.csdn.net/superjunjin/article/details/7853546" target="_blank" rel="external">http://blog.csdn.net/superjunjin/article/details/7853546</a><br><a href="http://blog.csdn.net/superjunjin/article/details/7855995" target="_blank" rel="external">http://blog.csdn.net/superjunjin/article/details/7855995</a><br><a href="http://blog.csdn.net/superjunjin/article/details/7862182" target="_blank" rel="external">http://blog.csdn.net/superjunjin/article/details/7862182</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017面试题整理&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="面试题" scheme="https://luhaoaimama1.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Camera的研究与封装</title>
    <link href="https://luhaoaimama1.github.io/2017/01/23/Camera%E8%B0%83%E7%A0%94/"/>
    <id>https://luhaoaimama1.github.io/2017/01/23/Camera调研/</id>
    <published>2017-01-23T05:19:37.000Z</published>
    <updated>2017-01-23T15:33:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于坐标轴分析 最终理解 Camera 与封装lib</p>
<a id="more"></a>
<h1 id="View-Camera-坐标轴分析"><a href="#View-Camera-坐标轴分析" class="headerlink" title="View,Camera 坐标轴分析"></a>View,Camera 坐标轴分析</h1><blockquote>
<p><a href="https://github.com/luhaoaimama1/ZAnimate" target="_blank" rel="external">下面的多图在此项目中</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">View</th>
<th style="text-align:center">Camera(锚点:左上角点)</th>
<th style="text-align:center">Camera Lib</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fc0em565jkg307i07i7wm.gif" alt=""></td>
<td style="text-align:center"><img src="https://ww2.sinaimg.cn/large/006tNbRwly1fc0f25baf7g307i07i1l1.gif" alt=""></td>
<td style="text-align:center"><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fc0f2btfm7g307i07i7wl.gif" alt=""></td>
</tr>
<tr>
<td style="text-align:center"><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fc0f6bb02pj30at08cwel.jpg" alt=""></td>
<td style="text-align:center"><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fc0fai83kyj30at08cglh.jpg" alt=""></td>
<td style="text-align:center">同view</td>
</tr>
<tr>
<td style="text-align:center">左手坐标系 <a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk1nSH681Fc4lk2iftz320K7Za" target="_blank" rel="external">判断依据</a></td>
<td style="text-align:center"><em>camera视角的图片锚点坐标系</em></td>
<td style="text-align:center">同view</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>camera视角的图片锚点坐标系</em>：其实用的也是左手坐标系,但是为什么会围绕X旋转180呢？ </p>
<p>回答：因为我们的API名字叫做Camera 他是以摄像机的角度去 理解做操作的； 可以自己拿手机拍照去 通过移动摄像机 而让里面的物体移动。就会明白了。 </p>
<p>Tips:Camera真实<strong>没有移动</strong>(因为getLocationX、Y、Z都是没有移动的)，只是以他的角度去理解； </p>
</blockquote>
<h1 id="理解-Camera的translate与rotate"><a href="#理解-Camera的translate与rotate" class="headerlink" title="理解 Camera的translate与rotate"></a>理解 Camera的translate与rotate</h1><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Applies a translation transform on all three axis.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> x The distance to translate by on the X axis</div><div class="line"> * <span class="doctag">@param</span> y The distance to translate by on the Y axis</div><div class="line"> * <span class="doctag">@param</span> z The distance to translate by on the Z axis</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> native void translate(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z);</div><div class="line"></div><div class="line"> <span class="comment">/**</span></div><div class="line"> * Applies a rotation transform around all three axis.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> x The angle of rotation around the X axis, in degrees</div><div class="line"> * <span class="doctag">@param</span> y The angle of rotation around the Y axis, in degrees</div><div class="line"> * <span class="doctag">@param</span> z The angle of rotation around the Z axis, in degrees</div><div class="line"> * </div><div class="line"> * <span class="doctag">@see</span> #rotateX(float)</div><div class="line"> * <span class="doctag">@see</span> #rotateY(float)</div><div class="line"> * <span class="doctag">@see</span> #rotateZ(float)</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> native void rotate(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z);</div></pre></td></tr></table></figure>
<p>看到没关键点是-&gt; <strong>axis 的位移与旋转</strong>；</p>
<h2 id="想要理解上面-先跟我做一些事情"><a href="#想要理解上面-先跟我做一些事情" class="headerlink" title="想要理解上面 先跟我做一些事情"></a>想要理解上面 先跟我做一些事情</h2><blockquote>
<p>锚点：左上角点</p>
</blockquote>
<p>拿起你的手机  平行面对你，已左上角为手机坐标系原点(任何时候 包括 旋转位移以后)。 </p>
<ul>
<li>围绕Y轴做旋转45，然后X位移一段距离distanceX。在旋转75°</li>
</ul>
<h2 id="从中明白了什么"><a href="#从中明白了什么" class="headerlink" title="从中明白了什么"></a>从中明白了什么</h2><blockquote>
<p>锚点：左上角点</p>
</blockquote>
<ul>
<li><p>明白什么叫做 axis 的位移与旋转。 就是每次操作都是以 手机左上角(相当于咱们的图片左上角)为坐标系</p>
</li>
<li><p>从整体来看我们经过了 三次操作，以每次操作之前，手机左上角的点为例，第一次操作点 记为 operate1，依次 operate2 ，operate3.那么从整体来看 我相当于  operate1 X轴:distanceX的点 rorate1 围绕operate1 旋转45°，然后围绕本身operate3 75°。总结为:</p>
<ul>
<li>既 旋转之后 +位移操作，就是相当于 <strong>[旋转之前+位移]之后的点</strong> 围绕 <strong>旋转之前的点</strong> 旋转，</li>
<li>旋转不加位移  就相当于 [锚点] 旋转。</li>
<li>这个手机外边的世界就暂且叫做合成坐标系,而手机左上角则暂且叫做锚点坐标系;<blockquote>
<p>不管做了多少次操作都遵循这个 规律；</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="Camera-传说中-移动旋转点的-解释"><a href="#Camera-传说中-移动旋转点的-解释" class="headerlink" title="Camera 传说中 移动旋转点的 解释"></a>Camera 传说中 移动旋转点的 解释</h1><blockquote>
<p>camera的合成坐标系 是 </p>
</blockquote>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="type">Matrix</span> temp = <span class="function"><span class="keyword">new</span> <span class="title">Matrix</span>();		<span class="comment">// 临时Matrix变量</span></span></div><div class="line"><span class="title">this</span>.<span class="title">getMatrix</span>(temp);			<span class="comment">// 获取Matrix</span></div><div class="line"><span class="title">temp</span>.<span class="title">preTranslate</span>(-centerX, -centerY);	<span class="comment">// 使用pre将旋转中心移动到和Camera位置相同。</span></div><div class="line"><span class="title">temp</span>.<span class="title">postTranslate</span>(centerX, centerY);	<span class="comment">// 使用post将图片(View)移动到原来的位置</span></div></pre></td></tr></table></figure>
<p>temp.preTranslate操作:是把最开的图片移动位置。</p>
<blockquote>
<p>center为例: 左上角(锚点)是center点了,因为开始的图片变了位置,左上角(锚点)对于camera的合成坐标系依然没变</p>
</blockquote>
<p>temp.postTranslate操作 移动的是 camera的合成坐标系</p>
<blockquote>
<p>Tips: 旋转的中心点依然是左上角点(锚点 例子中的center点),而不是post中的点。 </p>
</blockquote>
<h2 id="最后我还要提示下："><a href="#最后我还要提示下：" class="headerlink" title="最后我还要提示下："></a>最后我还要提示下：</h2><blockquote>
<p>我们的视角 就是view坐标系(所有View 大小 padding等等都是参考此来设计的)；</p>
</blockquote>
<ul>
<li>camera translate,rotate 是在合成坐标系里 的视角 ,位移旋转， 位移和旋转的值都是相对于 合成坐标系里 的视角,因为里面有摄像机 <blockquote>
<p>假如camera向下移动100 以我们的视角可能是89等,因为以camera坐标系的视角(包含摄像机 Z轴 视差等等因素)判定的；</p>
</blockquote>
</li>
<li>Matrix postTranslate 系列,则是 对于合成坐标系的操作， 更改的位置和旋转等。都是 相对于View坐标系的值 <blockquote>
<p>假如Matrix向下移动100  就是100 这是以View坐标系既我们的视角来判定的；</p>
</blockquote>
</li>
</ul>
<h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><blockquote>
<p><a href="https://github.com/luhaoaimama1/ZAnimate" target="_blank" rel="external">此demo在此项目中</a></p>
</blockquote>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fc0l088rrtg307i0dcdwu.gif" alt=""></p>
<p>左图关键代码：</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">camera</span>.save();</div><div class="line">  <span class="keyword">camera</span>.rotateX(-rotateDegree);</div><div class="line">  <span class="keyword">camera</span>.getMatrix(<span class="keyword">matrix</span>);</div><div class="line">  <span class="keyword">camera</span>.restore();</div><div class="line"></div><div class="line">  <span class="comment">// -viewWidth / 2 保持着竖线高度不变的，其他会倾斜；</span></div><div class="line">  <span class="keyword">matrix</span>.preTranslate(-viewWidth / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">  <span class="keyword">matrix</span>.postTranslate(viewWidth / <span class="number">2</span>, (<span class="keyword">float</span>) axisY);</div></pre></td></tr></table></figure>
<p>右图关键代码：把 <strong>postTranslate</strong>移动的 移动到了<strong>camera.transalte</strong></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">camera</span>.save();</div><div class="line">       <span class="keyword">camera</span>.rotateX(-rotateDegree);</div><div class="line">       <span class="keyword">camera</span>.translte(<span class="number">0</span>,(<span class="keyword">float</span>) axisY,<span class="number">0</span>)</div><div class="line">       <span class="keyword">camera</span>.getMatrix(<span class="keyword">matrix</span>);</div><div class="line">       <span class="keyword">camera</span>.restore();</div><div class="line"></div><div class="line">       <span class="comment">// -viewWidth / 2 保持着竖线高度不变的，其他会倾斜；</span></div><div class="line">       <span class="keyword">matrix</span>.preTranslate(-viewWidth / <span class="number">2</span>, <span class="number">0</span>);</div><div class="line">       <span class="keyword">matrix</span>.postTranslate(viewWidth / <span class="number">2</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>这里的问题是,0度的时候 还能看到？因为你camera.translte(0,(float) axisY,0),因为Y不在是0,和摄像机不保持相同高度后是可以看到的。所以这里用matrix.postTranslate比较好</p>
<p>这还算好的 如果摄像机移动Z轴的话  会出现和严重的问题,因为这仅仅是一段代码补全就暂且不说了；</p>
</blockquote>
<h1 id="封装Lib"><a href="#封装Lib" class="headerlink" title="封装Lib"></a>封装Lib</h1><blockquote>
<p>通过上面的理解 我们开始封装lib</p>
</blockquote>
<ol>
<li>首先更改Camera视角的坐标系为view坐标系 而不是camera的视角。</li>
<li><p>我们希望setPivot(float px, float py)或者setPivot(PivotType pivotType)的预设方式;</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   <span class="comment">*</span> <span class="comment">0</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">1</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">2</span></div><div class="line">   <span class="comment">*</span> <span class="comment">|</span>       <span class="comment">|</span></div><div class="line">   <span class="comment">*</span> <span class="comment">7</span>   <span class="comment">8</span>   <span class="comment">3</span></div><div class="line">   <span class="comment">*</span> <span class="comment">|</span>       <span class="comment">|</span></div><div class="line">   <span class="comment">*</span> <span class="comment">6</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">5</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="comment">4</span></div><div class="line">   <span class="comment">*/</span></div><div class="line">  <span class="comment">public</span> <span class="comment">enum</span> <span class="comment">PivotType</span> <span class="comment">&#123;</span></div><div class="line">      <span class="comment">None</span><span class="string">,</span></div><div class="line">      <span class="comment">LeftTop</span><span class="string">,</span> <span class="comment">LeftCenter</span><span class="string">,</span> <span class="comment">LeftBottom</span><span class="string">,</span></div><div class="line">      <span class="comment">RightTop</span><span class="string">,</span> <span class="comment">RightCenter</span><span class="string">,</span> <span class="comment">RightBottom</span><span class="string">,</span></div><div class="line">      <span class="comment">CenterTop</span><span class="string">,</span> <span class="comment">Center</span><span class="string">,</span> <span class="comment">CenterBottom</span><span class="string">,</span></div><div class="line">  <span class="comment">&#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>getMatrix的时候,matrix.preTranslate(x,y);操作, 但是不要postTranslate操作 因为post是移动整个camera的合成坐标系的;</p>
</li>
<li><p>最后我希望 类似AE那种可以绑定parent的形式,并且parent也可以绑定</p>
</li>
</ol>
<p>关于第4点,未改进的方式,记得这个上面提到的规律吧—-&gt;旋转之后 +位移操作，就是相当于 <strong>[旋转之前+位移]之后的点</strong> 围绕 <strong>旋转之前的点</strong> 旋转</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.translate</span>(<span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.tx</span>, <span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.ty</span>, <span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.tz</span>);</div><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.rotate</span>(<span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.rx</span>, <span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.ry</span>, <span class="selector-tag">parent</span><span class="selector-class">.parent</span><span class="selector-class">.rz</span>);</div><div class="line"></div><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.translate</span>(<span class="selector-tag">parent</span><span class="selector-class">.tx</span>, <span class="selector-tag">parent</span><span class="selector-class">.ty</span>, <span class="selector-tag">parent</span><span class="selector-class">.tz</span>);</div><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.rotate</span>(<span class="selector-tag">parent</span><span class="selector-class">.rx</span>, <span class="selector-tag">parent</span><span class="selector-class">.ry</span>, <span class="selector-tag">parent</span><span class="selector-class">.rz</span>);</div><div class="line"></div><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.translate</span>(<span class="selector-tag">tx</span>, <span class="selector-tag">ty</span>, <span class="selector-tag">tz</span>);</div><div class="line"><span class="selector-tag">cameraFinal</span><span class="selector-class">.rotate</span>(<span class="selector-tag">rx</span>, <span class="selector-tag">ry</span>, <span class="selector-tag">rz</span>);</div></pre></td></tr></table></figure>
<p>关于第4点,改进成</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">List&lt;Layer&gt; parentlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">     parentlist.<span class="built_in">add</span>(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">     Layer rootParent = parent;</div><div class="line">     <span class="keyword">while</span> (rootParent!=<span class="keyword">null</span>) &#123;</div><div class="line">         parentlist.<span class="built_in">add</span>(rootParent);</div><div class="line">         rootParent = rootParent.parent;</div><div class="line">     &#125;</div><div class="line"></div><div class="line"></div><div class="line">     cameraFinal.<span class="built_in">save</span>();</div><div class="line">     <span class="keyword">for</span> (<span class="built_in">int</span> i = parentlist.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">         Layer layer = parentlist.<span class="built_in">get</span>(i);</div><div class="line">         cameraFinal.<span class="built_in">translate</span>(layer.tx, layer.ty, layer.tz);</div><div class="line">         cameraFinal.<span class="built_in">rotate</span>(layer.rx, layer.ry, layer.rz);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     cameraFinal.getMatrix(matrix);</div><div class="line">     cameraFinal.restore();</div></pre></td></tr></table></figure>
<p>最后封装成两个类</p>
<blockquote>
<p><a href="https://github.com/luhaoaimama1/ZAnimate/blob/master/library/src/main/java/zone/com/zanimate/camera/CameraCorrect.java" target="_blank" rel="external">Camera封装类CameraCorrect</a><br><a href="https://github.com/luhaoaimama1/ZAnimate/blob/master/library/src/main/java/zone/com/zanimate/camera/Layer.java" target="_blank" rel="external">绑定parent封装类Layer</a></p>
</blockquote>
<p><a href="https://github.com/luhaoaimama1/ZAnimate" target="_blank" rel="external">demo范例:</a></p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fc0y5tuckfj30fg0rs0sz.jpg" alt=""></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="https://github.com/zhangyuChen1991/Roll3DImageView" target="_blank" rel="external">https://github.com/zhangyuChen1991/Roll3DImageView</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于坐标轴分析 最终理解 Camera 与封装lib&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="camera" scheme="https://luhaoaimama1.github.io/tags/camera/"/>
    
  </entry>
  
  <entry>
    <title>Android-BitmapComposer(类似于AE的合成模式)</title>
    <link href="https://luhaoaimama1.github.io/2017/01/19/BitmapComposer/"/>
    <id>https://luhaoaimama1.github.io/2017/01/19/BitmapComposer/</id>
    <published>2017-01-19T05:19:37.000Z</published>
    <updated>2017-01-23T02:47:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>灵感来源于AE,参考AE合成图的步骤;</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwly1fbvy8lrq8fj31h80ayt9l.jpg" alt=""></p>
<a id="more"></a>
<h1 id="封装后的使用方式"><a href="#封装后的使用方式" class="headerlink" title="封装后的使用方式"></a>封装后的使用方式</h1><ul>
<li>可以无限newLayer,并且每个layer对应的bitmap都有以下特征<ul>
<li>mask   PorterDuff.Mode 造作</li>
<li>colorFilter  滤镜操作</li>
<li>matrix  矩阵操作 既 位置,旋转缩放等。</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">BitmapComposer</span><span class="selector-class">.newComposition</span>(<span class="selector-tag">bt</span><span class="selector-class">.getWidth</span>(), <span class="selector-tag">bt</span><span class="selector-class">.getHeight</span>(), <span class="selector-tag">Bitmap</span><span class="selector-class">.Config</span><span class="selector-class">.ARGB_8888</span>)</div><div class="line"><span class="selector-class">.clear</span>()</div><div class="line"><span class="selector-class">.newLayer</span>(<span class="selector-tag">BitmapComposer</span><span class="selector-class">.Layer</span><span class="selector-class">.bitmap</span>(<span class="selector-tag">bt</span>)</div><div class="line">                   <span class="selector-class">.colorFilter</span>(<span class="selector-tag">new</span> <span class="selector-tag">ColorMatrixColorFilter</span>(<span class="selector-tag">colorMatrix</span>))</div><div class="line">                    <span class="selector-class">.matrix</span>(<span class="selector-tag">matrix</span>)  )</div><div class="line"><span class="selector-class">.newLayer</span>(<span class="selector-tag">BitmapComposer</span><span class="selector-class">.Layer</span><span class="selector-class">.bitmap</span>(<span class="selector-tag">bt</span>)</div><div class="line">          <span class="selector-class">.colorFilter</span>(<span class="selector-tag">new</span> <span class="selector-tag">ColorMatrixColorFilter</span>(<span class="selector-tag">colorMatrix</span>))</div><div class="line">          <span class="selector-class">.mask</span>(<span class="selector-tag">wave</span>, <span class="selector-tag">PorterDuff</span><span class="selector-class">.Mode</span><span class="selector-class">.DST_IN</span>)</div><div class="line">           <span class="selector-class">.matrix</span>(<span class="selector-tag">matrix</span>)    )</div><div class="line"><span class="selector-class">.render</span>();</div></pre></td></tr></table></figure>
<p><strong>实例demo</strong>:<a href="https://github.com/luhaoaimama1/zone-sdk" target="_blank" rel="external">zone-sdk项目</a>运行后:-&gt;动画、surfaceView、绘图方面的研究-&gt;波浪 进入即可看到;</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwly1fbvyespt80g307i0dcax1.gif" alt=""></p>
<blockquote>
<p>demo原理:第一层是 <strong>黑白图片</strong>,第二层是加过 <strong>波浪Mask(遮罩的-既android的PorterDuff)</strong>的<strong>原图</strong></p>
</blockquote>
<h1 id="代码范例"><a href="#代码范例" class="headerlink" title="代码范例:"></a>代码范例:</h1><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">image2.post(<span class="function"><span class="keyword">new</span> <span class="title">Runnable</span>() &#123;</span></div><div class="line">            @<span class="title">Override</span></div><div class="line">            <span class="title">public</span> <span class="title">void</span> <span class="title">run</span>() &#123;</div><div class="line">                <span class="title">Bitmap</span> <span class="title">bt</span> = <span class="title">SampleUtils</span>.<span class="title">load</span>(<span class="type">WaveActivity</span>.this, <span class="type">R</span>.drawable.aaaaaaaaaaaab)</div><div class="line">                        .<span class="title">bitmap</span>();</div><div class="line"></div><div class="line">                <span class="title">ColorMatrix</span> <span class="title">colorMatrix</span> = <span class="title">new</span> <span class="title">ColorMatrix</span>();</div><div class="line">                <span class="title">colorMatrix</span>.<span class="title">setSaturation</span>(<span class="number">0</span>);</div><div class="line"></div><div class="line">                <span class="title">BitmapComposer</span> <span class="title">bitmapComposer</span> = <span class="title">BitmapComposer</span>.<span class="title">newComposition</span>(bt.getWidth(), <span class="title">bt</span>.<span class="title">getHeight</span>(), <span class="title">Bitmap</span>.<span class="title">Config</span>.<span class="title">ARGB_8888</span>);</div><div class="line">                <span class="title">Matrix</span> <span class="title">first</span> = <span class="title">new</span> <span class="title">Matrix</span>();</div><div class="line">                <span class="title">first</span>.<span class="title">postTranslate</span>(<span class="number">0</span>, <span class="number">-20</span>);</div><div class="line">                <span class="title">new</span> <span class="title">WaveHelper</span>(bt.getWidth(), <span class="title">bt</span>.<span class="title">getHeight</span>(), <span class="title">new</span> <span class="title">WaveHelper</span>.<span class="title">RefreshCallback</span>() &#123;</div><div class="line"></div><div class="line">                    @<span class="title">Override</span></div><div class="line">                    <span class="title">public</span> <span class="title">void</span> <span class="title">refresh</span>(<span class="type">Bitmap</span> wave) &#123;</div><div class="line">                        <span class="title">Bitmap</span> <span class="title">render</span> = <span class="title">bitmapComposer</span>.<span class="title">clear</span>()</div><div class="line">                                .<span class="title">newLayer</span>(<span class="type">BitmapComposer</span>.<span class="type">Layer</span>.bitmap(bt)</div><div class="line">                                        .<span class="title">colorFilter</span>(new <span class="type">ColorMatrixColorFilter</span>(colorMatrix)))</div><div class="line">                                .<span class="title">newLayer</span>(</div><div class="line">                                        <span class="type">BitmapComposer</span>.<span class="type">Layer</span>.bitmap(bt)</div><div class="line"><span class="comment">//                                              .colorFilter(new ColorMatrixColorFilter(colorMatrix))</span></div><div class="line">                                                .<span class="title">mask</span>(wave, <span class="type">PorterDuff</span>.<span class="type">Mode</span>.<span class="type">DST_IN</span>)</div><div class="line"><span class="comment">//                                              .matrix(first)</span></div><div class="line">                                )</div><div class="line">                                .<span class="title">render</span>();</div><div class="line">                        <span class="title">image2</span>.<span class="title">setImageBitmap</span>(render);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="https://github.com/race604/WaveLoading" target="_blank" rel="external">https://github.com/race604/WaveLoading</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;灵感来源于AE,参考AE合成图的步骤;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ww4.sinaimg.cn/large/006tNbRwly1fbvy8lrq8fj31h80ayt9l.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="bitmap" scheme="https://luhaoaimama1.github.io/tags/bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Android-drawText()详解</title>
    <link href="https://luhaoaimama1.github.io/2016/12/18/drawText/"/>
    <id>https://luhaoaimama1.github.io/2016/12/18/drawText/</id>
    <published>2016-12-18T05:19:37.000Z</published>
    <updated>2017-01-19T09:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>全局声明<ul>
<li>canvas.drawText(string, <strong>baseLineX</strong>, <strong>baseLineY</strong>, paint)</li>
<li>baseLineY=基线的Y;</li>
<li>baseLineX=基线的X;</li>
<li>本篇以textSize=100为例</li>
</ul>
</li>
</ul>
<blockquote>
<p>API:canvas.drawText(String text,int start,int end,float x,float y, paint); //截取字符串 然后绘制     </p>
</blockquote>
<a id="more"></a>
<p><a id="way0"></a></p>
<h1 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h1><p><img src="http://img.blog.csdn.net/20151229092331153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<ul>
<li>除了基线以外，如上图所示，另外还有四条线(通过FontMetrics可以获取到)，分别是ascent,descent,top,bottom，他们的意义分别是：<ul>
<li>top: 可绘制的最高高度所在线</li>
<li>ascent: 系统建议的，绘制单个字符时，字符应当的最高高度所在线</li>
<li>descent:系统建议的，绘制单个字符时，字符应当的最低高度所在线</li>
<li>bottom: 可绘制的最低高度所在线</li>
</ul>
</li>
</ul>
<blockquote>
<p>[ascent,descent]与[top,bottom]的区别就是安全区与最大区域，但由于制式的不同，每个字体的显示区域并不一定一致，当遇到不一致时，就会裁剪。</p>
</blockquote>
<p><a id="way1"></a></p>
<h1 id="获取FontMetrics"><a href="#获取FontMetrics" class="headerlink" title="获取FontMetrics"></a>获取FontMetrics</h1><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paint.getFontMetricsInt()<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>FontMetricsInt: top=-106 ascent=-93 descent=24 bottom=28 leading=0</p>
<p><a id="way2"></a></p>
<h1 id="归纳重点"><a href="#归纳重点" class="headerlink" title="归纳重点"></a>归纳重点</h1><ul>
<li>TextSize的含义<ul>
<li>经测试 平时paint.setTextSize的值=descent+bounds.top;</li>
</ul>
</li>
<li>一个字的高度<ul>
<li>一个字的高度 并不是textSize  而是top与bottom差值(代表绘制一个TextSize大小的字所需要的空间);<blockquote>
<p>例如EditText里的字和光标发现高度不一致,光标比字高那么一点</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><a id="way3"></a></p>
<h1 id="测量宽度"><a href="#测量宽度" class="headerlink" title="测量宽度:"></a>测量宽度:</h1><p>通过paint(包括了 textSize),所以给定内容即可测量其宽度</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">width</span> = (<span class="keyword">int</span>) paint.measureText(content);</div></pre></td></tr></table></figure>
<p><a id="way4"></a></p>
<h1 id="测量所绘制的矩形范围"><a href="#测量所绘制的矩形范围" class="headerlink" title="测量所绘制的矩形范围:"></a>测量所绘制的矩形范围:</h1><p>通过paint(包括了 textSize),所以给定内容即可测量其宽度</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Rect bounds = <span class="built_in">new</span> Rect();</div><div class="line">paint.getTextBounds(<span class="built_in">content</span>, <span class="number">0</span>, <span class="built_in">content</span>.<span class="built_in">length</span>(), bounds);</div></pre></td></tr></table></figure>
<p>bounds：Rect(4, -75 - 347, 21)</p>
<blockquote>
<p>注意:这里仅仅是显示一个矩形范围,默认这里是baseLineX=0,baseLineY=0,LEFT模式;</p>
</blockquote>
<p><a id="way5"></a></p>
<h1 id="setTextAlign"><a href="#setTextAlign" class="headerlink" title="setTextAlign"></a>setTextAlign</h1><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb921d86qhj30jk0eq3ze.jpg" width="400"></p>
<ul>
<li>Left(默认模式):baseLineX在 绘制矩形bounds的左边</li>
<li>Center:baseLineX在 绘制矩形bounds的中间</li>
<li>Right:baseLineX在 绘制矩形bounds的右边</li>
</ul>
<p><a id="way6"></a></p>
<h1 id="如何把这个bounds移动到对应的字符显示位置呢"><a href="#如何把这个bounds移动到对应的字符显示位置呢" class="headerlink" title="如何把这个bounds移动到对应的字符显示位置呢?"></a>如何把这个bounds移动到对应的字符显示位置呢?</h1><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">canvas.drawText(<span class="keyword">string</span>, baseLineX, baseLineY, paint);</div><div class="line"><span class="keyword">int</span> <span class="built_in">width</span> = (<span class="keyword">int</span>) paint.measureText(content);</div><div class="line"><span class="built_in">switch</span> (paint.getTextAlign()) &#123;</div><div class="line">            <span class="built_in">case</span> LEFT:</div><div class="line">                bounds.offset(baseLineX, baseLineY);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="built_in">case</span> RIGHT:</div><div class="line">                bounds.offset(baseLineX- <span class="built_in">width</span>, baseLineY);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            <span class="built_in">case</span> CENTER:</div><div class="line">                bounds.offset(baseLineX- <span class="built_in">width</span>/ <span class="number">2</span>, baseLineY);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里的代码其实就是系统做的逻辑; </p>
<p>从默认的baseLineX=0,baseLineY=0,LEFT模式。转变到现在的值</p>
</blockquote>
<p><a id="way7"></a></p>
<h1 id="drawText的工具封装"><a href="#drawText的工具封装" class="headerlink" title="drawText的工具封装"></a><a href="https://github.com/luhaoaimama1/zone-sdk/blob/master/Android_Zone_Lib/src/and/utils/view/DrawUtils.java" target="_blank" rel="external">drawText的工具封装</a></h1><blockquote>
<p>在内部类Text里</p>
</blockquote>
<p>范例:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">DrawUtils</span><span class="selector-class">.Text</span><span class="selector-class">.with</span>(<span class="selector-tag">canvas</span>, <span class="selector-tag">content</span>, 0, <span class="selector-tag">y</span>, <span class="selector-tag">paint</span>)</div><div class="line">                       <span class="selector-class">.align</span>(<span class="selector-tag">align</span>)</div><div class="line">                       <span class="selector-class">.drawBound</span>(<span class="selector-tag">paintBounds</span>)</div><div class="line">                       <span class="selector-class">.show</span>(<span class="selector-tag">showType</span>);</div></pre></td></tr></table></figure></p>
<h1 id="Demo演示图-点击可进入代码"><a href="#Demo演示图-点击可进入代码" class="headerlink" title="Demo演示图-点击可进入代码"></a><a href="https://github.com/luhaoaimama1/zone-sdk/blob/master/Android_Zone_Test/src/com/example/mylib_test/activity/animal/viewa/DrawTextView.java" target="_blank" rel="external">Demo演示图-点击可进入代码</a></h1><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb921xmxlsj30fm0rgmyg.jpg" width="400"></p>
<h1 id="对应-align-与show方法的-范例"><a href="#对应-align-与show方法的-范例" class="headerlink" title="对应 align 与show方法的 范例"></a>对应 align 与show方法的 范例</h1><p><strong>实例demo</strong>:<a href="https://github.com/luhaoaimama1/zone-sdk" target="_blank" rel="external">zone-sdk项目</a>运行后:-&gt;动画、surfaceView、绘图方面的研究-&gt;drawtext工具测试 进入即可看到;</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwly1fbw1kiaxghj30ka0gqjrw.jpg" alt=""></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://blog.csdn.net/harvic880925/article/details/50423762" target="_blank" rel="external">http://blog.csdn.net/harvic880925/article/details/50423762</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;全局声明&lt;ul&gt;
&lt;li&gt;canvas.drawText(string, &lt;strong&gt;baseLineX&lt;/strong&gt;, &lt;strong&gt;baseLineY&lt;/strong&gt;, paint)&lt;/li&gt;
&lt;li&gt;baseLineY=基线的Y;&lt;/li&gt;
&lt;li&gt;baseLineX=基线的X;&lt;/li&gt;
&lt;li&gt;本篇以textSize=100为例&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;API:canvas.drawText(String text,int start,int end,float x,float y, paint); //截取字符串 然后绘制     &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="canvas" scheme="https://luhaoaimama1.github.io/tags/canvas/"/>
    
      <category term="drawText" scheme="https://luhaoaimama1.github.io/tags/drawText/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机总结---类初始化过程</title>
    <link href="https://luhaoaimama1.github.io/2016/12/07/JVM-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://luhaoaimama1.github.io/2016/12/07/JVM-类初始化过程/</id>
    <published>2016-12-07T05:19:37.000Z</published>
    <updated>2017-03-14T07:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h1 id="类的初始化过程"><a href="#类的初始化过程" class="headerlink" title="类的初始化过程"></a>类的初始化过程</h1><p><img src="http://images0.cnblogs.com/blog2015/544748/201505/251937420687138.jpg" alt=""></p>
<h2 id="非法向前引用"><a href="#非法向前引用" class="headerlink" title="非法向前引用"></a>非法向前引用</h2><p>编译器手机的顺序是由语句在源文件中出现的顺序决定的,静态语句块中只能访问到定义在静态语句之前的变量,定义它之后的变量,可以赋值,但不能访问</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>&#123;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">         i=<span class="number">0</span>;</div><div class="line">         system.<span class="keyword">out</span>.print(i);<span class="comment">//非法向前引用</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><clinit>(类构造器方法):在jvm第一次加载class文件时调用,如果类或者接口没有静态语句块,也没有对变量的赋值,那么编译器可以不为这个类生成<clinit>方法并且他被加锁了,既不能做耗时操作。</clinit></clinit></p>
<p>Tips:如果在此方法中耗时很长,就可能造成多个进程阻塞;</p>
</blockquote>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><ul>
<li>加载<blockquote>
<p>加载与连接阶段的验证动作是交叉进行的</p>
</blockquote>
</li>
<li><p>连接</p>
<ul>
<li>验证<ul>
<li>文件格式验证。是否符合Class文件格式的规范</li>
<li>语义分析。父类,抽象类,接口等。</li>
<li>字节码验证</li>
<li>符号引用验证  </li>
</ul>
</li>
<li><p>准备</p>
<blockquote>
<p>正式为类变量分配内存并设置类变量初始值的阶段</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">value</span>=<span class="number">123</span>;</div><div class="line"><span class="comment">//final的话  准备阶段既123;</span></div><div class="line"><span class="comment">//非常量的 static 则准备阶段是0;&lt;clinit&gt;类构造方法执行才会变成123</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>解析</p>
<blockquote>
<p>可选的,loadClass第二个参数来判定是否需要解释。这里的解释是根据勒种的符号引用查找相应的实体,在把符号引用替换成一个直接引用的过程。</p>
</blockquote>
</li>
</ul>
</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>
<h2 id="类什么时候才被初始化"><a href="#类什么时候才被初始化" class="headerlink" title="类什么时候才被初始化"></a>类什么时候才被初始化</h2><ul>
<li><p>只有这6中情况才会导致类的类的初始化</p>
<ul>
<li>创建类的实例，也就是new一个对象</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(“com.lyj.load”)）</li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
</li>
<li><p>所有引用类的方法都不会触发初始化,称为被动引用。</p>
<blockquote>
<p>类引用父类的静态字段,不会导致该类被初始化</p>
</blockquote>
</li>
<li><p>类的初始化步骤：</p>
<ul>
<li>如果这个类还没有被加载和链接，那先进行加载和链接</li>
<li>假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）</li>
<li>加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</li>
</ul>
</li>
</ul>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>Java虚拟器角度仅仅有两种不同的类加载器:</p>
<p>一种启动类加载器(Bootstrap ClassLoader):C++语言实现是虚拟器自身的一部分;</p>
<p>另一种是所有其他的类加载器(java语言,JVM之外 继承ClassLoader)</p>
<blockquote>
<p>更详细:</p>
</blockquote>
<p>!<img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb917dq0h0j30hs0cd775.jpg" alt=""></p>
<p>Bootstrap ClassLoader:负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class既核心API(ExtClassLoader和AppClassLoader也在此时被加载)，由C++实现，不是ClassLoader子类</p>
<p>Extension ClassLoader:负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p>
<p>App ClassLoader:负责记载classpath中指定的jar包及目录中class.可以通过getSystemClassLoader()方法获得</p>
<p>Custom ClassLoader:属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p>
<blockquote>
<p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p>
</blockquote>
<h3 id="为什么这么设计"><a href="#为什么这么设计" class="headerlink" title="为什么这么设计?"></a>为什么这么设计?</h3><p>类加载器:任何一个类都需要加载它的类加载器和这个类一同确立其在java虚拟机唯一性。每个类加载器都有类名称空间。</p>
<blockquote>
<p>两个类是否相同,是由同一个类加载器为前提下才有意义.相同是指equals、instanceof isAssignalbeFrom isIntance等;</p>
</blockquote>
<p>例如类java.lang.Object,他存放在rt.jar中,无论哪个类加载器加载这个类,最终都是委派给魔性最顶端的启动类加载器进行加载。因此Object类在程序的各种类加载器环境中都是<strong>同一个类</strong>。<br>相反如果没有使用,各个类加载自行加载的话。那么系统将出现多个不同的Object类,那么java类型体系中最基本的行为也无法保证;</p>
<p>以下是ClassLoader的源码,实现很简单<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">rotected synchronized <span class="class"><span class="keyword">Class</span>&lt;?&gt; <span class="title">loadClass</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">boolean</span> <span class="title">resolve</span>)</span></div><div class="line">	throws ClassNotFoundException</div><div class="line">    &#123;</div><div class="line">	// First, check <span class="keyword">if</span> the <span class="class"><span class="keyword">class</span> <span class="title">has</span> <span class="title">already</span> <span class="title">been</span> <span class="title">loaded</span></span></div><div class="line">	<span class="class"><span class="keyword">Class</span> <span class="title">c</span> = <span class="title">findLoadedClass</span>(<span class="title">name</span>);</span></div><div class="line">	<span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</div><div class="line">	    <span class="keyword">try</span> &#123;</div><div class="line">		<span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</div><div class="line">		    //从父加载器加载</div><div class="line">		    c = parent.loadClass(name, <span class="literal">false</span>);</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		    //从bootstrap loader加载</div><div class="line">		    c = findBootstrapClassOrNull(name);</div><div class="line">		&#125;</div><div class="line">	    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                // ClassNotFoundException thrown <span class="keyword">if</span> <span class="class"><span class="keyword">class</span> <span class="title">not</span> <span class="title">found</span></span></div><div class="line">                // from the non-<span class="literal">null</span> parent <span class="class"><span class="keyword">class</span> <span class="title">loader</span></span></div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</div><div class="line">	        // <span class="keyword">If</span> still <span class="keyword">not</span> found, <span class="keyword">then</span> invoke findClass in order</div><div class="line">	        // <span class="keyword">to</span> find the <span class="class"><span class="keyword">class</span>.</span></div><div class="line">	        c = findClass(name);</div><div class="line">	    &#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span> (resolve) &#123;</div><div class="line">	    resolveClass(c);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> c;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>其他思考的问题    </p>
<ul>
<li>类加载的逻辑应该在哪里写?<blockquote>
<p>jdk 1.2之后 已经不提倡用户覆盖loadClass方法了,而是应当在自己的类加载逻辑写到findClass()中。因为loadClass()方法如果加载失败就会调用自己的findClass()去加载。这样就能保证 写出来的类加载器是符合双亲委派模式的</p>
</blockquote>
</li>
<li><p>如果依赖特定的扩展包,需要继承特定的classLoader吗?</p>
<blockquote>
<p>下面的默认构造器, 要在父亲是AppClassLoader的基础上 加载自己的类。不然会破坏双亲的<br>总结:新的ClassLoader需要旧的去委托。如果不这样就会导致在同一个类出现在不同的ClassLoader中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="title">ClassLoader</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">//getSystemClassLoader()其实就是AppClassLoader</span></div><div class="line">    <span class="keyword">this</span>(checkCreateClassLoader(), getSystemClassLoader());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>如果类已经 加载过了,那么应该在哪里存储 下一次去验证是否加载过呢?</p>
<blockquote>
<p>可以通过该ClassLoader中 <code>protect</code> findLoadedClass(name)方法找到。</p>
</blockquote>
</li>
<li>resolveClass 什么时候使用</li>
</ul>
</li>
<li><p>类加载过程总结</p>
<ul>
<li>得到类的原始字节数组byte[]。</li>
<li>findClass里通过defineClass(name, buf, 0, buf.length) 完成类加载。    </li>
</ul>
</li>
</ul>
<h3 id="举例分析流程"><a href="#举例分析流程" class="headerlink" title="举例分析流程"></a>举例分析流程</h3><p>如果一个非ClassPath目录下的新的数据流类通过新的ClassLoader(NewClassLoader)去加载。</p>
<p>Parent:</p>
<blockquote>
<p>NewClassLoader-AppClassLoader-&gt;ExtClassLoader</p>
</blockquote>
<p>第一次初始化</p>
<blockquote>
<p>loadClass:每次findLoadedClass都找不到</p>
<p>NewClassLoader-AppClassLoader-&gt;ExtClassLoader</p>
</blockquote>
<p>findClass:(loadClass的逆序)</p>
<blockquote>
<p>ExtClassLoader-&gt;AppClassLoader-&gt;NewClassLoader(最后在此define 生成类后loadClass一次)</p>
</blockquote>
<p>第二次初始化</p>
<blockquote>
<p>loadClass:第一个NewClassLoader中findLoadedClass就找到了</p>
</blockquote>
<p>NB技巧:子类可以公开父类中的protected的方法;</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">findClass_</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>.findClass();<span class="comment">//protected</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/luhaoaimama1/JavaZone/blob/master/JavaTest_Zone/src/classload/ClassLoaderTest.java" target="_blank" rel="external">Demo Code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;类的初始化过程&quot;&gt;&lt;a href=&quot;#类的初始化过程&quot; class=&quot;headerlink&quot; title=&quot;类的初始化过程&quot;&gt;&lt;/a&gt;类的初始化过程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://images0.cnblogs
    
    </summary>
    
      <category term="jvm" scheme="https://luhaoaimama1.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://luhaoaimama1.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机总结</title>
    <link href="https://luhaoaimama1.github.io/2016/12/05/JVM/"/>
    <id>https://luhaoaimama1.github.io/2016/12/05/JVM/</id>
    <published>2016-12-05T05:19:37.000Z</published>
    <updated>2017-03-14T07:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h1><ul>
<li>Java 程序的执行过程：Java 源代码文件（.Java文件）-&gt; Java Compiler（Java编译器）-&gt;Java 字节码文件（.class文件）-&gt;类加载器（Class Loader）-&gt;Runtime Data Area（运行时数据）-&gt; Execution Engine（执行引擎）</li>
<li>各种基本类型:boolean、byte、char、short、int、float、long、double;</li>
<li>对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针</li>
<li>局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;</li>
<li>额外了解:插入式注解处理器:需要继承AbstractProcessor;</li>
</ul>
<a id="more"></a>
<h1 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h1><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb913k1wc0j30f50a53zv.jpg" alt=""></p>
<blockquote>
<p>本地方法栈和虚拟机栈有的虚拟机是不分的;</p>
</blockquote>
<p><a id="way1-1"></a></p>
<h2 id="jvm各个区域的概要"><a href="#jvm各个区域的概要" class="headerlink" title="jvm各个区域的概要"></a>jvm各个区域的概要</h2><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb91bux68qj31f016w41s.jpg" alt=""></p>
<p><a id="way1-2"></a></p>
<h2 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h2><p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb913u4clkj317k0h6abh.jpg" alt=""></p>
<blockquote>
<p>句柄优势:reference本身不需要修改,只会改变句柄中的实例数据指针</p>
<p>直接指针访问优势:最大好处速度快。节省了一次指针定位的开销;</p>
<p>HotSpot采用此方式</p>
</blockquote>
<p><a id="way1-3"></a></p>
<h2 id="对象的布局"><a href="#对象的布局" class="headerlink" title="对象的布局"></a>对象的布局</h2><p>3个区域:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</p>
<blockquote>
<p>header:(官方称 Mark Word)运行时数据,入哈希码(HashCode)、GC分代年龄 锁状态标识</p>
<p>Instance Data:类型指针,既对象只想他的类元数据的指针;</p>
<p>Padding:因为对象的大小必须是8字节的整数倍。如果数据没有对齐。需要Padding来补全</p>
</blockquote>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><ul>
<li>主要思考的问题:<ul>
<li>标记-那些内存(那些死,那些活着)需要回收?</li>
<li>什么时候回收?</li>
<li>如何回收?</li>
</ul>
</li>
</ul>
<p><a id="way2-1"></a></p>
<h1 id="标记概要"><a href="#标记概要" class="headerlink" title="标记概要"></a>标记概要</h1><h2 id="标记算法"><a href="#标记算法" class="headerlink" title="标记算法"></a>标记算法</h2><p>1)引用计数法(不能用):每当一个地方引用它时,计数器+1,引用失效时,计数器-1,任何时刻计数器为0的对象就是不可能在被使用</p>
<blockquote>
<p>java没有用 最主要的原因很难解决对象之间互相循环引用的问题;</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Object instance=<span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        ReferenceCountingGC objA=  <span class="keyword">new</span> <span class="type">ReferenceCountingGC</span>();</div><div class="line">        ReferenceCountingGC objB=  <span class="keyword">new</span> <span class="type">ReferenceCountingGC</span>();</div><div class="line">        objA.instance=objB;</div><div class="line">        objB.instance=objA;</div><div class="line">        objA=<span class="literal">null</span>;</div><div class="line">        objB=<span class="literal">null</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2)可达性分析算法:<br><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9143ha08j30cx08zmx7.jpg" alt=""></p>
<ul>
<li>Java 语言中,可作为GC Roots的对象包括下面几种;<ul>
<li>虚拟机栈中(栈帧中的本地变量表)的引用对象</li>
<li>方法区中类静态属性引用对象</li>
<li>方法区中类常量引用对象</li>
<li>本地方法栈JNI引用的对象</li>
</ul>
</li>
</ul>
<p><a id="way2-2"></a></p>
<h2 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h2><ul>
<li>引用分为四种 强,软,弱,虚四种 强度依次减弱<ul>
<li>强引用:类似Object obj=new Object() 这类引用,只要强引用还在,垃圾收集器就永远不会回收被引用的对象;</li>
<li>软引用:用来描述一些还有用但并未必须的对象。内存溢出异常之前,会把这些对象列入回收范围之内进行二次回收。如果回收后还没有足够的内存这回OOM;</li>
<li>弱引用:用来描述非必须的对象。若引用关联的对象只能活到下一次垃圾回收之前;</li>
<li>虚引用:唯一目的对象被回收时收到一个系统通知</li>
</ul>
</li>
</ul>
<p><a id="way2-3"></a></p>
<h2 id="不可达对象的最后历程"><a href="#不可达对象的最后历程" class="headerlink" title="不可达对象的最后历程"></a>不可达对象的最后历程</h2><blockquote>
<p>总结:finalize()方法不执行或者只能执行一次</p>
</blockquote>
<p>不可达对象,也并非”非死不可” 这时候是在缓刑阶段。要真正宣告死亡,至少要经理两次标记过程。<br>如果对象进行可达性分析后发现没有GC Roots相关联的引用链,会被第一次标记并且进行一次筛选,筛选条件是此对象是否有必要执行finalize()方法。<br>对象没有覆盖finalize方法(逃脱命运的最后机会),或者<strong>finalize()方法被虚拟机掉用过(只能执行一次)</strong>,虚拟机将这两种情况都视为”没有必要执行”<br>如果被判定有必要执行,那么对象会放置叫一个F-Queue的队列之中,并且稍后虚拟机自动建立Finalize线程去执行它既finalize方法<br>但并不承诺会等待他运行结束,怕死循环或者运行缓慢。finalize方法是逃脱命运的最后机会,如果没有逃脱就真的被回收了;</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p><a id="way3-1"></a></p>
<h2 id="标记-清除算法-基础算法-剩下的都是基于它的不足而进行改进的"><a href="#标记-清除算法-基础算法-剩下的都是基于它的不足而进行改进的" class="headerlink" title="标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)"></a>标记-清除算法(基础算法,剩下的都是基于它的不足而进行改进的)</h2><p>标记:标记所有需要回收的对象</p>
<p>清除:统一回收所有被标记的对象</p>
<blockquote>
<p>不足1:效率问题,标记和清除效率都不高;<br>不足2:空间问题,产生大量的不连续的内存碎片</p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb914owdnxj30ii0c2t9t.jpg" alt=""><br><a id="way3-2"></a></p>
<h2 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h2><p>内存容量划分两个大小相等的两块,每次使用其中的一块。这块用完了复制存活的对象到另一块,在把这块清理掉</p>
<blockquote>
<p>不足:代价太高 把内存缩小为原来的一半;</p>
</blockquote>
<p>现代的商用虚拟街都采用这种算法来回收新生代;因为新生代都是 <strong>朝生暮死</strong> 所以不需要1:1来划分<br>而将内存分为一块较大的Eden 和两个较小的Survivor 默认大小比;8:1, 每次新生代中可用的内存空间是整个新生代容量的90=(Eden+Survivor),<br>“浪费” 10 因为没办法保证回收只有不多于10的存活,Survivor空间不够需要老年代进行 担保;<br><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb915j8lkhj30ik0bi0tt.jpg" alt=""><br><a id="way3-3"></a></p>
<h2 id="标记-整理-Mark-Compact-算法-老年代常用"><a href="#标记-整理-Mark-Compact-算法-老年代常用" class="headerlink" title="标记-整理(Mark-Compact)算法(老年代常用)"></a>标记-整理(Mark-Compact)算法(老年代常用)</h2><p>标记和以前一样,后续步骤不是直接回收,而是存活对象向一端移动,然后清理边界以外的内存;<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb915o8c50j30in0bcab3.jpg" alt=""><br><a id="way3-4"></a></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>根据对象存活周期将内存划分不同的几块。一般堆分为 新生代 和老年代。这样根据年代的特点采用最适当的收集算法</p>
<p>新生代:少量存活 选择复制算法</p>
<p>老年代:存活率高,没有额外空间担保,必须使用 标记清理 或者标记整理;</p>
<blockquote>
<p>GC会产生停顿(Sun也叫它 “Stop The World”),OoMap 存放着GC Roots,不是每条指令都生成一个。</p>
<p>不是任何时都能停下来进行 GC ,只有在 “特定的位置” 才可以GC 这个位置也叫安全点(Safepoint)</p>
<p>安全点的选定基本上是以程序”是否具有让程序长时间执行的特征”为标准选定的</p>
</blockquote>
<p>关于安全点另一个需要考虑的就是如何在GC发生的时让所有线程都”跑”到最近的安全点上在停下来;有两种方案</p>
<p>抢先式中断(Preemptive Suspension)(现在几乎都这种方案):不需要线程的执行代码主动配合,GC发生时候先把线程全部中断,如果有线程不在安全点,就回复线程让它跑到安全点。</p>
<p>主动式中断(Voluntary Suspension):当GC需要中断线程的时候,不对线程造作,仅仅简单地设置一个标志位,各个线程执行的时候主动去轮询这个标志位,发现中断标志位真就挂起,轮询标志的地方安全点重合。<br>而对于不执行的线程,任何时间都是安全的也称为安全区;</p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><a id="way4-1"></a></p>
<h2 id="7种垃圾收集器的介绍"><a href="#7种垃圾收集器的介绍" class="headerlink" title="7种垃圾收集器的介绍"></a>7种垃圾收集器的介绍</h2><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb9166bymyj30e00b5wfn.jpg" alt=""><br><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb9160tldaj31kw0jgacz.jpg" alt=""></p>
<blockquote>
<p>G1收集器因为没有商用的就不写了;</p>
</blockquote>
<p>Serial:单线程收集器，在进行垃圾收集时，必须要暂停其他所有的工作线程，直到它收集结束。</p>
<blockquote>
<ol>
<li><p>需要STW（Stop The World），停顿时间长。</p>
</li>
<li><p>简单高效，对于单个CPU环境而言，Serial收集器由于没有线程交互开销，可以获取最高的单线程收集效率。</p>
</li>
</ol>
</blockquote>
<p>ParNew:是Serial的多线程版本，除了使用多线程进行垃圾收集外，其他行为与Serial完全一样</p>
<blockquote>
<p>Tips：1.Server模式下虚拟机的首选新生收集器，与CMS进行搭配使用。</p>
</blockquote>
<p>Parallel Scavenge:目标是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)，高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务，并且虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应调节策略。<br>Serial Old:老年代的单线程收集器，使用标记 - 整理算法，<br>Parallel Old:老年代的多线程收集器，使用标记 - 整理算法，吞吐量优先，适合于Parallel Scavenge搭配使用</p>
<ul>
<li>CMS（Conrrurent Mark Sweep）收集器是以获取最短回收停顿时间为目标的收集器。使用标记 - 清除算法，收集过程分为如下四步：<ul>
<li>初始标记，标记GCRoots能直接关联到的对象，时间很短。</li>
<li>并发标记，进行GCRoots Tracing（可达性分析）过程，时间很长。</li>
<li>重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。</li>
<li>并发清除，回收内存空间，时间很长。<blockquote>
<p>其中，并发标记与并发清除两个阶段耗时最长，但是可以与用户线程并发执行<br>Tips：1. 对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<ol>
<li><p>无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。</p>
</li>
<li><p>由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了-XX:+UseCMSCompactAtFullCollection参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，-XX:+CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。</p>
</li>
</ol>
</blockquote>
<p><a id="way4-2"></a></p>
<h2 id="理解一下GC日志"><a href="#理解一下GC日志" class="headerlink" title="理解一下GC日志"></a>理解一下GC日志</h2><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="name">GC</span> (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">6270</span>K-&gt;584K(<span class="name">9216K</span>)] <span class="number">11390</span>K-&gt;5712K(<span class="name">19456K</span>), <span class="number">0.0011969</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.00, real=0.00 secs]</div></pre></td></tr></table></figure>
<ol>
<li>[GC (System.gc())]与[Full GC (System.gc())]，说明垃圾收集的停顿类型，不是区分新生代GC和老年代GC的，如果有Full，则表示此次GC发生了Stop The World。</li>
<li>PSYoungGen: 6270K-&gt;584K(9216K)，表示，新生代：该内存区域GC前已使用容量 -&gt; 该内存区域GC后已使用容量（该内存区域总容量）</li>
<li>11390K-&gt;5712K(19456K)，表示，GC前Java堆已使用的容量 -&gt; GC后Java堆已使用的容量（Java堆总容量）</li>
<li>0.0011969 secs，表示GC所占用的时间，单位为秒。</li>
<li>[Times: user=0.00 sys=0.00, real=0.00 secs]，表示GC的更具体的时间，user代表用户态消耗的CPU时间，sys代表内核态消耗的CPU时间，real代表操作从开始到结束所经过的墙钟时间。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，如等待磁盘IO，等待线程阻塞，CPU时间则不包含这些耗时。当系统有多CPU或者多核时，多线程操作会叠加这些CPU时间，所以读者看到user或者sys时间超过real时间也是很正常的</li>
</ol>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb916pqo7bj30lm09taas.jpg" alt=""></p>
<ul>
<li>GC类型<ul>
<li>Minor GC:指发生在新生代的垃圾收集动作，非常频繁，速度较快。</li>
<li>Major GC:指发生在老年代的GC，出现Major GC，经常会伴随一次Minor GC，同时Minor GC也会引起Major GC，一般在GC日志中统称为GC，不频繁。</li>
<li>Full GC:指发生在老年代和新生代的GC，速度很慢，需要Stop The World。</li>
</ul>
</li>
</ul>
<p>大对象直接进入老年代:大对象就是大量连续内存空间的Java对象,典型的就是很长的字符串及数组。并且内存超过虚拟机设置大对象的值;</p>
<p>长期存活的对象进入老年代:jvm给每个对象定义一个对象年龄计数器。如果eden出生并经过第一次Minor GC后仍然存活并且能被Survivor容纳的话,将被移动到Survivor空间并将对象年龄设为1.对象在Survivor区每”熬过”一次Minor GC则年龄+1,当年龄达到一定程度(默认15岁),下一次将会被晋升老年代。</p>
<p>动态对象年龄判定:为了更好的适应内存状况。如果在Survivor空间中相同年龄的所有对象大小的综合大于Survivor的一半,那么大于等于这个年龄的将被一起带入老年代</p>
<blockquote>
<p>Tips:研究代码对象到底怎么回收请看Page:93(深入理解JVM虚拟机第二版)</p>
</blockquote>
<p><a id="way4-3"></a></p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb9170p4unj30b5087gm9.jpg" alt=""></p>
<p><a id="way4-4"></a></p>
<h2 id="虚拟机参数设置"><a href="#虚拟机参数设置" class="headerlink" title="虚拟机参数设置;"></a>虚拟机参数设置;</h2><p>代码的运行参数设置为： -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8<br><img src="http://images2015.cnblogs.com/blog/616953/201602/616953-20160226111115693-1490327308.png" alt="">  </p>
<h1 id="静态分派与动态分派"><a href="#静态分派与动态分派" class="headerlink" title="静态分派与动态分派"></a>静态分派与动态分派</h1><p><a id="way6-1"></a>  </p>
<h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Map</span> <span class="built_in">map</span>=<span class="literal">new</span> HashMap();</div></pre></td></tr></table></figure>
<p>Map(静态类型,外观类型接口类型(我习惯叫)):其变化仅在使用时发生，变量本身的静态类型不会改变，并且最终的静态类型是在编译期可知的。</p>
<p>HashMap(实际类型):其变化的结果在运行期才可确定，编译器不编译程序时并不知道一个对象的实际类型是什么。</p>
<ul>
<li>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。<ul>
<li>①.静态分派典型的应用是方法重载，</li>
<li>②.静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的 </li>
<li>③.对于方法参数的匹配也是根据变量的静态类型来确定，在很多情况下根据参数的类型并不能找到唯一的方法调用，这个时候的处理方式是找到一个最合适的方法。比如：</li>
</ul>
</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OverLoad</span> &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello char"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">int</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello int"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">long</span> arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello long"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Character arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Character"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Serializable arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello Serializable"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params">Object arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello object"</span>);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"><span class="keyword">char</span> ...arg</span>) </span>&#123;  </div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"hello arg..."</span>);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </div><div class="line">        sayHello(<span class="string">'a'</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从头注解方法，结果会按顺序输出。</p>
<p>1、基本类型是重载按char-&gt;int-&gt;long-&gt;float-&gt;double-&gt;Character-&gt;Serializable(因为Character实现了他)顺序匹配的。</p>
<p>2、可变参数的重载优先级是最低的。</p>
<blockquote>
<p>Tips:如果出现了两个参数分别为Serializable和Comparable(Character实现这两个),编译器无法确定自动转型那种类型。提示类型模糊拒绝编译;</p>
</blockquote>
<p><a id="way6-2"></a>  </p>
<h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><p>方法执行会找到对应的实际类型。</p>
<p><a id="way7-1"></a>  </p>
<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><blockquote>
<p>NB之处 不仅仅能实现别人的接口,也能实现自己的接口这样相当于 对象本身了,但是可以却可以在方法执行之前或之后搞事情了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;  </div><div class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span></span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;  </div><div class="line">            System.out.println(<span class="string">"hello world"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;  </div><div class="line">        Object originalObj;  </div><div class="line">        <span class="function">Object <span class="title">bind</span><span class="params">(Object originalObj)</span></span>&#123;  </div><div class="line">            <span class="keyword">this</span>.originalObj = originalObj;  </div><div class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(originalObj.getClass().getClassLoader(), originalObj.getClass(),  </div><div class="line">                    getInterfaces(),<span class="keyword">this</span>);  </div><div class="line">        &#125;  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span>  </span></div><div class="line">                <span class="keyword">throws</span> Throwable &#123;  </div><div class="line">            System.out.println(<span class="string">"welcome"</span>);  </div><div class="line">            <span class="keyword">return</span> method.invoke(originalObj, args);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line">        <span class="comment">/* 设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请生工创建) */</span></div><div class="line">     	System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</div><div class="line">        IHello hello = (IHello)<span class="keyword">new</span> DynamicProxy().bind(<span class="keyword">new</span> Hello());  </div><div class="line">        hello.sayHello();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”)-&gt;设置此系统属性,让JVM生成的Proxy类写入文件.保存路径为：com/sun/proxy(如果不存在请生工创建)</p>
</blockquote>
<p>java逆向工具:为了解决把1.5中编写的代码放到1.4 1.3的环境部署使用的问题。比较出色的Retrotranslator</p>
<h1 id="Java魔法糖"><a href="#Java魔法糖" class="headerlink" title="Java魔法糖"></a>Java魔法糖</h1><p><a id="way8-1"></a> </p>
<h2 id="泛型与擦除"><a href="#泛型与擦除" class="headerlink" title="泛型与擦除"></a>泛型与擦除</h2><p>编译后的字节码文件中替换为原生类型,并且在相应的位置插入强制转换;</p>
<blockquote>
<p>所以泛型遇到重载,不会执行编译;例如参数List<integer>和List<string>编译后的文件是一样的所以你懂的;</string></integer></p>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sugar</span> </span>&#123;</div><div class="line">    <span class="comment">//看bin目录下的编译文件;</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//泛型 自动装箱,自动拆箱,便利循环,变长参数;</span></div><div class="line">        List&lt;Integer&gt; list= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</div><div class="line">        <span class="keyword">int</span> <span class="keyword">sum</span>=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> integer : list) &#123;</div><div class="line">            <span class="keyword">sum</span>+=integer;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="keyword">sum</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后文件<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Sugar &#123;</div><div class="line">    <span class="keyword">public</span> Sugar() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line">        List list = Arrays.asList(new <span class="keyword">Integer</span>[]&#123;<span class="keyword">Integer</span>.valueOf(<span class="number">1</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">2</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">3</span>), <span class="keyword">Integer</span>.valueOf(<span class="number">4</span>)&#125;);</div><div class="line">        <span class="built_in">int</span> <span class="built_in">sum</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="built_in">int</span> <span class="keyword">integer</span>;</div><div class="line">        for(Iterator var3 = list.iterator(); var3.hasNext(); <span class="built_in">sum</span> += <span class="keyword">integer</span>) &#123;</div><div class="line">            <span class="keyword">integer</span> = ((<span class="keyword">Integer</span>)var3.next()).intValue();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.<span class="keyword">out</span>.println(<span class="built_in">sum</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p><a href="https://github.com/luhaoaimama1/AndroidNote-Zone/blob/master/note/jvm/%E8%AF%AD%E6%B3%95%E7%B3%96/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E9%99%B7%E9%98%B1.java" target="_blank" rel="external">自动装箱陷阱</a></p>
</blockquote>
<h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><p><a id="way9-1"></a> </p>
<h2 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h2><p>当定义为volatile之后具备两种特性:<br>第一保证此变量对<strong>所有线程</strong>的可见性。当一个线程修改了这个值,新值对于其他线程来说立即可知;<br>第二:禁止指令重排序优化;</p>
<blockquote>
<p>这个目录的&lt;<strong>volatile教材</strong>&gt;文件夹有对应的范例;</p>
<p>volatile和普通变量性能几乎没有区别,比synchronized关键字快;</p>
</blockquote>
<p><a id="way9-2"></a> </p>
<h2 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h2><p>主要两种:协同式调度和抢占式调度<br>协同(不用):执行时间由线程本身来控制。吧自己工作执行完后主动通知系统切换到另一个线程;</p>
<blockquote>
<p>坏处:如果线程出现堵塞那么所有都堵塞了</p>
</blockquote>
<p>抢占:系统分配时间,切换不由线程本身来决定</p>
<blockquote>
<p>Thread.yield()可以让出执行时间.获取时间则没有办法;</p>
<p>额外知识 ++不是原子性,AtomicInteger CAS(原子性)来避免阻塞同步;</p>
</blockquote>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://www.cnblogs.com/leesf456/p/5218594.html" target="_blank" rel="external">http://www.cnblogs.com/leesf456/p/5218594.html</a></p>
<p><a href="http://itfeifei.win/2017/03/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/#0-sqq-1-86202-9737f6f9e09dfaf5d3fd14d775bfee85" target="_blank" rel="external">http://itfeifei.win/2017/03/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3Java%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98/#0-sqq-1-86202-9737f6f9e09dfaf5d3fd14d775bfee85</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;基础了解&quot;&gt;&lt;a href=&quot;#基础了解&quot; class=&quot;headerlink&quot; title=&quot;基础了解&quot;&gt;&lt;/a&gt;基础了解&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Java 程序的执行过程：Java 源代码文件（.Java文件）-&amp;gt; Java Compiler（Java编译器）-&amp;gt;Java 字节码文件（.class文件）-&amp;gt;类加载器（Class Loader）-&amp;gt;Runtime Data Area（运行时数据）-&amp;gt; Execution Engine（执行引擎）&lt;/li&gt;
&lt;li&gt;各种基本类型:boolean、byte、char、short、int、float、long、double;&lt;/li&gt;
&lt;li&gt;对象引用:reference类型 不等于对象本身,可能是对象的句柄也可能对象的引用指针&lt;/li&gt;
&lt;li&gt;局部变量默认没有初始值,不赋值是不可以使用的。和类变量(默认是有的)不一样;&lt;/li&gt;
&lt;li&gt;额外了解:插入式注解处理器:需要继承AbstractProcessor;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://luhaoaimama1.github.io/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://luhaoaimama1.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Android-Rebound(弹簧系统-让动画不再僵硬)的简单使用与源码分析</title>
    <link href="https://luhaoaimama1.github.io/2016/11/20/Rebound/"/>
    <id>https://luhaoaimama1.github.io/2016/11/20/Rebound/</id>
    <published>2016-11-20T05:19:37.000Z</published>
    <updated>2017-03-16T02:25:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>综述：Rebound 通过胡克定律，实现的一个类似“弹簧”动画效果的第三方工具包。</p>
</blockquote>
<a id="more"></a>
<p><a href="https://github.com/luhaoaimama1/ReboundDemo" target="_blank" rel="external">官方demo摘出</a></p>
<h1 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h1><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Spring spring =  SpringSystem.create().createSpring();</div><div class="line">spring.addListener(<span class="keyword">new</span> SimpleSpringListener() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onSpringUpdate</span><span class="params">(Spring spring)</span> </span>&#123;</div><div class="line">                   <span class="keyword">super</span>.onSpringUpdate(spring);</div><div class="line">                   <span class="keyword">double</span> currentValue = spring.getCurrentValue();</div><div class="line">                   <span class="keyword">double</span> valueMap = SpringUtil.mapValueFromRangeToRange(currentValue, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">                   ViewHelper.setScaleX(siv, (<span class="keyword">float</span>) valueMap);</div><div class="line">                   ViewHelper.setScaleY(siv, (<span class="keyword">float</span>) valueMap);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">spring.setEndValue(<span class="number">1</span>);<span class="comment">//默认endValue是0；</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Ps:SpringUtil.mapValueFromRangeToRange(currentValue, 0, 1, 1, 0.5);</p>
<p>是映射工具类 0-&gt;1的转映射到1-&gt;0.5</p>
</blockquote>
<h1 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h1><blockquote>
<p>SimpleSpringListener实现了SpringListener</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">SpringListener</span> &#123;</div><div class="line">  <span class="comment">// 在首次开始运动时候调用。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onSpringActivate</span>(<span class="params">Spring spring</span>)</span>;</div><div class="line">  <span class="comment">//在advance后调用，表示状态更新。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onSpringUpdate</span>(<span class="params">Spring spring</span>)</span>;</div><div class="line">  <span class="comment">//在进入rest状态后调用。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onSpringAtRest</span>(<span class="params">Spring spring</span>)</span>;</div><div class="line">  <span class="comment">//则略有不同，仅在setEndValue中被调用，且该Spring需要在运动中且新的endValue不等于原endValue。</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onSpringEndStateChange</span>(<span class="params">Spring spring</span>)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><blockquote>
<p>拉力(tension) default:40—&gt;拉力越大，弹簧效果越明显</p>
<p>摩擦力(friction) default:7–&gt;弹框效果阻力越大、越不明显</p>
<p>Ps:如果这个摩擦力的值设置为0，就像真实世界中处于真空状态，一点摩擦力都没有，这个弹簧效果会一直无限制重复下去，根本停不下来</p>
</blockquote>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">spring.setSpringConfig(<span class="keyword">new</span> <span class="type">SpringConfig</span>(tensionValue, frictionValue));</div></pre></td></tr></table></figure>
<h1 id="setEndValue与setCurrentValue的区别"><a href="#setEndValue与setCurrentValue的区别" class="headerlink" title="setEndValue与setCurrentValue的区别"></a>setEndValue与setCurrentValue的区别</h1><blockquote>
<p>end是一个值变化的过程,currentValue是表示插入一个值，表示一个瞬间(因为reset了~)；</p>
<p>Ps:setAtRest()会让他停止动画；</p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb91ocxcvsj30l40guq4f.jpg" width="500"></p>
<h1 id="连锁动画"><a href="#连锁动画" class="headerlink" title="连锁动画"></a>连锁动画</h1><figure class="highlight pony"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="type">SpringChain</span> mSpringChain = <span class="type">SpringChain</span>.create();</div><div class="line">mSpringChain.addSpring(<span class="function"><span class="keyword">new</span> <span class="title">SimpleSpringListener</span>()&#123;&#125;);</span></div><div class="line"><span class="title">mSpringChain</span>.<span class="title">setControlSpringIndex</span>(<span class="number">2</span>).<span class="title">getControlSpring</span>().<span class="title">setEndValue</span>(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<ul>
<li><p>SpringChain这个类，创建它有两个create方法：</p>
<ul>
<li>默认无参数create()</li>
<li><p>有参数的create(int mainTension,int mainFriction,int attachmentTension,int attachmentFriction)</p>
<blockquote>
<p>mainTension:主导spring的拉力系数，mainFriction:主导Spring的摩擦力系数，</p>
<p>attachmentTensio,attachmentFriction:表示附属的拉力和摩擦力系数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>SpringChain</code>需要设置一个起主导控制作用的Spring，通过setControlSpringIndex方法来设置</p>
<p><code>getControlSpring()</code>代表 获得主导的Spring</p>
<p><code>addSpring里</code>其实直接new了.  通过mSpringChain.getAllSprings()可以获取到注册到mSpringChain里的所有Spring</p>
</blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb91okt78nj30oq09udgk.jpg" width="500"></p>
<h1 id="官方小球demo解析"><a href="#官方小球demo解析" class="headerlink" title="官方小球demo解析"></a>官方小球demo解析</h1><ul>
<li><p>setVelocity</p>
<blockquote>
<p>会根据当前的速度计算剩下的位置；类似setEndValue 是一个值的变化 而不是瞬间；</p>
<p>Ps:根据官方小球demo,setVelocity之前 会把拉力设置为0 可能是为了拉力不影响速度的值吧；</p>
<p>Tip:setEndValue 则是和拉力有关系没速度没关系。所以下面代码在setEndValue使用之前 把拉力从0改成20</p>
</blockquote>
</li>
<li><p>SpringSystemListener（SpringSystem.addListener）</p>
<ul>
<li>onBeforeIntegrate 每次计算之前</li>
<li>onAfterIntegrate  每次计算之后</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么在onAfterIntegrate里写 而不是onBeforeIntegrate 因为如果出界后可以马上放回来。</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">springSystem = SpringSystem.create();</div><div class="line">springSystem.addListener(<span class="keyword">this</span>);</div><div class="line">xSpring = springSystem.createSpring();</div><div class="line">ySpring = springSystem.createSpring();</div><div class="line"></div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> onBeforeIntegrate(BaseSpringSystem springSystem) &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> onAfterIntegrate(BaseSpringSystem springSystem) &#123;</div><div class="line">    <span class="comment">//x就不写了 同y</span></div><div class="line">    <span class="keyword">if</span> (y + radius &gt;= getHeight()) &#123;</div><div class="line">        <span class="comment">//球碰到或出边界  吧速度返过来 然后setCurrentValue注意后边有个false 是让动画继续的意思；</span></div><div class="line">       ySpring.setVelocity(-ySpring.getVelocity());</div><div class="line">        <span class="comment">//ySpring.getCurrentValue() - (y + radius - getHeight()) 表示如果出界 就把他放回界内；</span></div><div class="line">       ySpring.setCurrentValue(ySpring.getCurrentValue() - (y + radius - getHeight()), <span class="keyword">false</span>);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">if</span> (y - radius &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//同上</span></div><div class="line">       ySpring.setVelocity(-ySpring.getVelocity());</div><div class="line">       ySpring.setCurrentValue(ySpring.getCurrentValue() - (y - radius), <span class="keyword">false</span>);</div><div class="line">     &#125;</div><div class="line"> </div><div class="line">     <span class="keyword">for</span> (PointF <span class="built_in">point</span> : points) &#123;</div><div class="line">       <span class="keyword">if</span> (<span class="built_in">dist</span>(x, y, <span class="built_in">point</span>.x, <span class="built_in">point</span>.y) &lt; attractionThreshold &amp;&amp;</div><div class="line">           Math.<span class="built_in">abs</span>(xSpring.getVelocity()) &lt; <span class="number">900</span> &amp;&amp;</div><div class="line">           Math.<span class="built_in">abs</span>(ySpring.getVelocity()) &lt; <span class="number">900</span> &amp;&amp;</div><div class="line">           !dragging) &#123;</div><div class="line">           <span class="comment">//如果速度小于某个值 并且在某个圆的一定范围内 并且手没有拖拽,则用setEndValue平滑过渡到某一点；</span></div><div class="line">         xSpring.setSpringConfig(CONVERGING);</div><div class="line">         xSpring.setEndValue(<span class="built_in">point</span>.x);</div><div class="line">         <span class="comment">//CONVERGING=SpringConfig.fromOrigamiTensionAndFriction(20, 3); </span></div><div class="line">         <span class="comment">//这里为什么把拉力弄成20？因为setEndValue和速度没关系和拉力有关系被；</span></div><div class="line">         ySpring.setSpringConfig(CONVERGING);</div><div class="line">         ySpring.setEndValue(<span class="built_in">point</span>.y);</div><div class="line">       &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简单的源码流程分析图"><a href="#简单的源码流程分析图" class="headerlink" title="简单的源码流程分析图"></a>简单的源码流程分析图</h1><p><img src="https://ww1.sinaimg.cn/large/006tKfTcgw1fb91oqry1sj31jq0wa78w.jpg" alt=""></p>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="http://blog.csdn.net/hanhailong726188/article/details/50687466" target="_blank" rel="external">http://blog.csdn.net/hanhailong726188/article/details/50687466</a></p>
<p><a href="http://www.jianshu.com/p/9d56d92d337c" target="_blank" rel="external">http://www.jianshu.com/p/9d56d92d337c</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;综述：Rebound 通过胡克定律，实现的一个类似“弹簧”动画效果的第三方工具包。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="源码分析" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/"/>
    
      <category term="动画" scheme="https://luhaoaimama1.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/android/%E5%8A%A8%E7%94%BB/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="动画" scheme="https://luhaoaimama1.github.io/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="Rebound" scheme="https://luhaoaimama1.github.io/tags/Rebound/"/>
    
  </entry>
  
  <entry>
    <title>Android-View的drawing缓存系统</title>
    <link href="https://luhaoaimama1.github.io/2016/11/10/CacheSystem/"/>
    <id>https://luhaoaimama1.github.io/2016/11/10/CacheSystem/</id>
    <published>2016-11-10T05:19:37.000Z</published>
    <updated>2016-12-30T14:21:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲述关于View中关键词Drawing的方法~</p>
<a id="more"></a>
<blockquote>
<p><strong>可视区域</strong>：如果view，上半显示，下半超出屏幕不显示，那么可视区域是<strong>上半</strong>，而不是整个</p>
</blockquote>
<h1 id="View中方法"><a href="#View中方法" class="headerlink" title="View中方法"></a>View中方法</h1><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setDrawingCacheEnabled(boolean enabled)</td>
<td style="text-align:center">是否开启缓存，如果开启 绘制会快点,关闭的话 缓存会清除</td>
</tr>
<tr>
<td style="text-align:center">isDrawingCacheEnabled()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">getDrawingCache(boolean autoScale)</td>
<td style="text-align:center">包含buildDrawingCache</td>
</tr>
<tr>
<td style="text-align:center">buildDrawingCache(boolean autoScale)</td>
<td style="text-align:center">autoScale false(<strong>常用</strong>)为view大小,true会缩放；getDrawingCacheBackgroundColor会修改位图的config</td>
</tr>
<tr>
<td style="text-align:center">destroyDrawingCache()</td>
<td style="text-align:center">清除缓存</td>
</tr>
</tbody>
</table>
<p>获取cache通常会占用一定的内存，所以通常不需要的时候有必要对其进行清理，通过destroyDrawingCache或setDrawingCacheEnabled(false)实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲述关于View中关键词Drawing的方法~&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="drawing" scheme="https://luhaoaimama1.github.io/tags/drawing/"/>
    
  </entry>
  
  <entry>
    <title>Android-CoordinateSystem</title>
    <link href="https://luhaoaimama1.github.io/2016/11/05/CoordinateSystem/"/>
    <id>https://luhaoaimama1.github.io/2016/11/05/CoordinateSystem/</id>
    <published>2016-11-05T05:19:37.000Z</published>
    <updated>2016-12-30T14:23:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲述关于View中坐标系系统~</p>
<a id="more"></a>
<blockquote>
<p><strong>可视区域</strong>：如果view，上半显示，下半超出屏幕不显示，那么可视区域是<strong>上半</strong>，而不是整个；</p>
</blockquote>
<h1 id="View中方法"><a href="#View中方法" class="headerlink" title="View中方法"></a>View中方法</h1><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">坐标系</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getX/Y</td>
<td style="text-align:center">parent</td>
<td style="text-align:center">mLeft/mTop + getTranslationX/Y()</td>
</tr>
<tr>
<td style="text-align:center">getWidth,getHeight</td>
<td style="text-align:center">自己</td>
<td style="text-align:center">获取宽高</td>
</tr>
<tr>
<td style="text-align:center">getLeft,getTop,getRight,getBottom</td>
<td style="text-align:center">parent</td>
<td style="text-align:center">view到parent某一方向的距离</td>
</tr>
<tr>
<td style="text-align:center">getLocalVisibleRect</td>
<td style="text-align:center">自己</td>
<td style="text-align:center">可视区域</td>
</tr>
<tr>
<td style="text-align:center">getGlobalVisibleRect</td>
<td style="text-align:center">srceen</td>
<td style="text-align:center">可视区域</td>
</tr>
<tr>
<td style="text-align:center">getDrawingRect</td>
<td style="text-align:center">自己</td>
<td style="text-align:center">自身滚动后的Rect</td>
</tr>
<tr>
<td style="text-align:center">getHitRect</td>
<td style="text-align:center">parent</td>
<td style="text-align:center">相当于getLeft/Top等值放入Rect</td>
</tr>
<tr>
<td style="text-align:center">getLocationOnScreen</td>
<td style="text-align:center">srceen</td>
<td style="text-align:center">获取左上角的点在srceen的位置</td>
</tr>
<tr>
<td style="text-align:center">getLocationInWindow</td>
<td style="text-align:center">window(Activity为Dialog的时候和 screen不一样大)</td>
<td style="text-align:center">获取左上角的点在window的位置</td>
</tr>
<tr>
<td style="text-align:center">getWindowVisibleDisplayFrame</td>
<td style="text-align:center">screen</td>
<td style="text-align:center">获取到程序显示的区域，包括标题栏，但不包括状态栏。</td>
</tr>
</tbody>
</table>
<h1 id="Event中方法"><a href="#Event中方法" class="headerlink" title="Event中方法"></a>Event中方法</h1><table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">坐标系</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">getX/Y</td>
<td style="text-align:center">自己</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">getRawX/Y</td>
<td style="text-align:center">Srceen</td>
</tr>
</tbody>
</table>
<h1 id="View的滑动方法"><a href="#View的滑动方法" class="headerlink" title="View的滑动方法"></a>View的滑动方法</h1><blockquote>
<p>坐标系均为  <strong>自己</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">View的滑动方法</th>
<th style="text-align:center">效果及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">offsetLeftAndRight/offsetTopAndBottom(int offset)</td>
<td style="text-align:center">水平/竖直方向挪动View,getLeft()/getTop会变的.<code>注意:requestLayout后一些值丢失</code></td>
</tr>
<tr>
<td style="text-align:center">scrollTo(int x, int y)</td>
<td style="text-align:center">将View中内容滑动到相应的位置，x，y为正则向xy轴反方向移动。</td>
</tr>
<tr>
<td style="text-align:center">scrollBy(int x, int y)</td>
<td style="text-align:center">在scrollTo()的基础上继续滑动xy。</td>
</tr>
<tr>
<td style="text-align:center">setScrollX/setScrollY(int value)</td>
<td style="text-align:center">实质为scrollTo()，只是只改变X/Y轴滑动。</td>
</tr>
<tr>
<td style="text-align:center">getScrollX()/getScrollY()</td>
<td style="text-align:center">获取当前滑动位置偏移量。</td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲述关于View中坐标系系统~&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="坐标系" scheme="https://luhaoaimama1.github.io/tags/%E5%9D%90%E6%A0%87%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Android-NestedScrolling Child与Parent的实例学习</title>
    <link href="https://luhaoaimama1.github.io/2016/10/26/NestedScrolling/"/>
    <id>https://luhaoaimama1.github.io/2016/10/26/NestedScrolling/</id>
    <published>2016-10-26T05:19:37.000Z</published>
    <updated>2016-12-30T14:24:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>遵守约定：就是google写了一套约定规范 这样大家都照规定写就可以兼容了；<br><strong>实例demo</strong>:<a href="https://github.com/luhaoaimama1/zone-sdk" target="_blank" rel="external">zone-sdk项目</a>运行后:-&gt;onTouch事件传递与其辅助类的研究-&gt;即可看到;</p>
<a id="more"></a>
<h1 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h1><blockquote>
<p><a href="https://segmentfault.com/a/1190000002873657" target="_blank" rel="external">如果不是很了解请先看此</a></p>
<p>方法对应：子view会 触发 父view方法。一般是子view发起调用，父view接受回调。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">子view</th>
<th style="text-align:center">父view</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">startNestedScroll</td>
<td style="text-align:center">onStartNestedScroll、onNestedScrollAccepted</td>
</tr>
<tr>
<td style="text-align:center">dispatchNestedPreScroll(child消耗前传递给 parent)</td>
<td style="text-align:center">onNestedPreScroll(子view消耗前)</td>
</tr>
<tr>
<td style="text-align:center">dispatchNestedScroll(child消耗后传递给 parent)</td>
<td style="text-align:center">onNestedScroll(子view消耗后)</td>
</tr>
<tr>
<td style="text-align:center">stopNestedScroll</td>
<td style="text-align:center">onStopNestedScroll</td>
</tr>
</tbody>
</table>
<blockquote>
<p>fling和 Scroll 类似 就不说了</p>
</blockquote>
<h1 id="Parent"><a href="#Parent" class="headerlink" title="Parent"></a>Parent</h1><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk2vEyiC22IktY2lqqNl1d1jF9" target="_blank" rel="external"><code>parent流程接入</code></a>   <a href="https://github.com/luhaoaimama1/zone-sdk/blob/master/Android_Zone_Test/src/com/example/mylib_test/activity/touch/NestedScrollingActivity_hongParent.java" target="_blank" rel="external"><code>parent代码实例</code></a></p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">在写具体的实现前，先对需要用到的上述方法做一下简单的介绍：</div><div class="line"></div><div class="line">onStartNestedScroll该方法，一定要按照自己的需求返回true，该方法决定了当前控件是否能接收到其内部<span class="keyword">View</span>(非并非是直接子<span class="keyword">View</span>)</div><div class="line">滑动时的参数；假设你只涉及到纵向滑动，这里可以根据nestedScrollAxes这个参数，进行纵向判断。</div><div class="line"></div><div class="line">onNestedPreScroll该方法的会传入内部<span class="keyword">View</span>移动的dx,dy，如果你需要消耗一定的dx,dy，就通过最后一个参数consumed进行指定，</div><div class="line">例如我要消耗一半的dy，就可以写consumed[<span class="number">1</span>]=dy/<span class="number">2</span>；（消耗后别以为完事了 需要自己调用scroller）</div><div class="line"></div><div class="line">onNestedScroll这个不常用 主要是子<span class="keyword">view</span>滑动后的剩下的位移交给NestedParent处理</div><div class="line"></div><div class="line">onNestedPreFling你可以捕获对内部<span class="keyword">View</span>的fling事件，如果<span class="keyword">return</span> true则表示拦截掉内部<span class="keyword">View</span>的事件。</div><div class="line">（消耗后别以为完事了 需要自己调用scroller的fling）</div><div class="line"></div><div class="line">onNestedFling：同onNestedScroll不咋常用</div></pre></td></tr></table></figure>
<blockquote>
<p>摘自<em>HongYang</em>: <a href="http://blog.csdn.net/lmj623565791/article/details/52204039" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/52204039</a></p>
</blockquote>
<h1 id="Child"><a href="#Child" class="headerlink" title="Child"></a>Child</h1><p><a href="http://fromwiz.com/share/s/3Hsjaq1-lQ9Q2SChN02Hkyvk0hpNyB0-1QGL2Fj4sK1tPrPG" target="_blank" rel="external"><code>child流程接入</code></a>  <a href="https://github.com/luhaoaimama1/zone-sdk/blob/master/Android_Zone_Test/src/com/example/mylib_test/activity/touch/NestedScrollingActivity_Child.java" target="_blank" rel="external"><code>child代码实例</code></a> </p>
<h2 id="方法的使用时机"><a href="#方法的使用时机" class="headerlink" title="方法的使用时机:"></a>方法的使用时机:</h2><p>startNestedScroll,stopNestedScroll；</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb8yykhy0yj30m808i76m.jpg" alt=""></p>
<p>dispatchNestedPreScroll使用时机  此例为RecyclerView的内容；<br>(因为是子view消耗钱 父消耗 )  所以 用if判断 父亲是否消耗；</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb8yyf39tvj30jg04y402.jpg" alt=""></p>
<p>dispatchNestedScroll  则和上边不同；是child先消耗了；在吧剩下的给NestedParent；看他消耗不；</p>
<blockquote>
<p>参考RecyclerView</p>
</blockquote>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb8yy026faj30m80hgjxf.jpg" alt=""></p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>1.抖动问题：offsetInWindow 如果不加这个参数会出现抖动，</p>
<blockquote>
<p>因为父亲消耗后，布局会偏移导致  每次的触摸事件e 其实也跟着偏移了(偏移量是上一次的布局的位移)所以e需要修正；</p>
</blockquote>
<h1 id="Reference-amp-Thanks："><a href="#Reference-amp-Thanks：" class="headerlink" title="Reference&amp;Thanks："></a>Reference&amp;Thanks：</h1><p><a href="https://segmentfault.com/a/1190000002873657" target="_blank" rel="external">https://segmentfault.com/a/1190000002873657</a></p>
<p><a href="http://blog.csdn.net/lmj623565791/article/details/52204039" target="_blank" rel="external">http://blog.csdn.net/lmj623565791/article/details/52204039</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;遵守约定：就是google写了一套约定规范 这样大家都照规定写就可以兼容了；&lt;br&gt;&lt;strong&gt;实例demo&lt;/strong&gt;:&lt;a href=&quot;https://github.com/luhaoaimama1/zone-sdk&quot;&gt;zone-sdk项目&lt;/a&gt;运行后:-&amp;gt;onTouch事件传递与其辅助类的研究-&amp;gt;即可看到;&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="事件传递" scheme="https://luhaoaimama1.github.io/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    
      <category term="NestedScrolling" scheme="https://luhaoaimama1.github.io/tags/NestedScrolling/"/>
    
  </entry>
  
  <entry>
    <title>Android-事件传递的学习</title>
    <link href="https://luhaoaimama1.github.io/2016/09/17/EventPass/"/>
    <id>https://luhaoaimama1.github.io/2016/09/17/EventPass/</id>
    <published>2016-09-17T05:19:37.000Z</published>
    <updated>2017-04-12T14:02:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究分发流程,总结为伪代码便于理解,然后研究源码,最后探究Method之requestDisallowInterceptTouchEvent</p>
<a id="more"></a>
<h1 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent"></a>dispatchTouchEvent</h1><h2 id="View总结"><a href="#View总结" class="headerlink" title="View总结:"></a>View总结:</h2><blockquote>
<p>onTouchListener -&gt; onTouchEvent -&gt; onLongClickListener -&gt; onClickListener</p>
</blockquote>
<ul>
<li>View: <ul>
<li>onTouchListener如果设置了 就不会走onTouchEvent了</li>
<li>super.onTouchEvent():包含了 onLongClickListener onClickListener 的事件处理;</li>
<li>但是onTouchEvent()是由dispatchTouchEvent()传递过来的</li>
</ul>
</li>
</ul>
<h2 id="处理特殊图形点击事件的几种方式"><a href="#处理特殊图形点击事件的几种方式" class="headerlink" title="处理特殊图形点击事件的几种方式 :"></a>处理特殊图形点击事件的几种方式 :</h2><p>通过path绘制特殊的点击范围, 放入Region中 然后通过contains是否包含即可</p>
<h3 id="兼容onClick1"><a href="#兼容onClick1" class="headerlink" title="兼容onClick1:"></a>兼容onClick1:</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> @<span class="function">Override</span></div><div class="line">    <span class="keyword">public</span> boolean <span class="title">dispatchTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>) &#123;</div><div class="line">        <span class="keyword">return</span> isEventInPath(<span class="keyword">event</span>)?super.dispatchTouchEvent(<span class="keyword">event</span>);</div><div class="line">    &#125;</div><div class="line">参考：http:<span class="comment">//blog.csdn.net/qibin0506/article/details/52676670</span></div></pre></td></tr></table></figure>
<h3 id="兼容onClick2"><a href="#兼容onClick2" class="headerlink" title="兼容onClick2:"></a>兼容onClick2:</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> isEventInPath(event)?<span class="keyword">super</span>.onTouchEvent(event):<span class="keyword">false</span>;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="自己的回调监听"><a href="#自己的回调监听" class="headerlink" title="自己的回调监听:"></a>自己的回调监听:</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> @<span class="function">Override</span></div><div class="line">    <span class="keyword">public</span> boolean <span class="title">onTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>) &#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">event</span>.getActionMasked()) &#123;</div><div class="line">        mListener.onCenterCliched();<span class="comment">//</span></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">   	<span class="comment">// 点击事件监听器</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">MenuListener</span> &#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCenterCliched</span>(<span class="params"></span>)</span>;</div><div class="line">        &#125;</div><div class="line">参考：http:<span class="comment">//www.gcssloop.com/customview/touch-matrix-region</span></div></pre></td></tr></table></figure>
<h2 id="伪代码分析"><a href="#伪代码分析" class="headerlink" title="伪代码分析"></a>伪代码分析</h2><blockquote>
<p>上述伪代码总结为下； 基本关键点已经还原~</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</div><div class="line">     <span class="keyword">if</span> (onTouchListener != <span class="keyword">null</span>)</div><div class="line">         result = onTouch();</div><div class="line">     <span class="keyword">if</span> (!result) &#123;</div><div class="line">         result = onTouchEvent(e) &#123;</div><div class="line">             <span class="comment">// 检查各种 clickable 如果有一个会 是true就会走</span></div><div class="line">             <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">                     (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">                     (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">                 </div><div class="line">                 <span class="keyword">case</span>:down</div><div class="line">                 mHasPerformedLongPress = <span class="keyword">false</span>;<span class="comment">//设置标识</span></div><div class="line">                 postDelay（mPendingCheckForTap, ViewConfiguration.getLongPressTimeout()）</div><div class="line">                 <span class="comment">//mPendingCheckForTap线程执行后更改为true; 并执行onLongClickListener</span></div><div class="line">                 </div><div class="line">                 <span class="keyword">case</span>:up</div><div class="line">                 <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</div><div class="line">                     removeLongPressCallback();  <span class="comment">// 移除长按</span></div><div class="line">                     执行onClickListener</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;                        <span class="comment">// ◀︎表示事件被消费</span></div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ViewGroup总结："><a href="#ViewGroup总结：" class="headerlink" title="ViewGroup总结："></a>ViewGroup总结：</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">     <span class="keyword">boolean</span> handled=<span class="keyword">false</span>,intercepted= <span class="keyword">false</span>;</div><div class="line">      <span class="comment">//--------拦截判断--------</span></div><div class="line">     <span class="comment">//disallowIntercept与requestDisallowInterceptTouchEvent(boolean)设置的值有关；</span></div><div class="line">     <span class="keyword">if</span>(disallowIntercept)</div><div class="line">       intercepted = onInterceptTouchEvent(ev)</div><div class="line">     <span class="keyword">else</span></div><div class="line">       intercepted=<span class="keyword">false</span>;</div><div class="line">     <span class="comment">//--------拦截结束--------</span></div><div class="line">     <span class="keyword">if</span> (!intercepted) &#123;</div><div class="line">     <span class="comment">//不拦截的话</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">                 <span class="comment">//如果有上一个dispatch返回true了 这个直接跳出for循环；</span></div><div class="line">                 <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) </div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                 <span class="comment">//dispatchTransformedTouchEvent:这个就是会调用child.dispatchTouchEvent</span></div><div class="line">                 <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">                   <span class="comment">//addTouchTarget方法里会给mFirstTouchTarget赋值；</span></div><div class="line">                   newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">                 &#125;</div><div class="line">            &#125;</div><div class="line">     &#125;</div><div class="line">   <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; </div><div class="line">       <span class="comment">//dispatchTransformedTouchEvent 因为传递null的view最后会走 super(就是view).dispatchTouchEvent()方法</span></div><div class="line">       handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">               TouchTarget.ALL_POINTER_IDS);</div><div class="line">   &#125; </div><div class="line">       </div><div class="line"><span class="keyword">return</span> handled;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="源码探究"><a href="#源码探究" class="headerlink" title="源码探究"></a>源码探究</h1><p>View dispatchTouchEvent<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">dispatchTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>) </span>&#123;</div><div class="line">    boolean result = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(<span class="keyword">event</span>)) &#123;</div><div class="line">              <span class="comment">//noinspection SimplifiableIfStatement</span></div><div class="line">              ListenerInfo li = mListenerInfo;</div><div class="line">              <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span></div><div class="line">                      &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</div><div class="line">                      &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, <span class="keyword">event</span>)) &#123;</div><div class="line">                   <span class="comment">//如果 不是ENABLED 并且 setOnTouchListener</span></div><div class="line">                  result = <span class="literal">true</span>;</div><div class="line">              &#125;</div><div class="line">  </div><div class="line">              <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(<span class="keyword">event</span>)) &#123;</div><div class="line">              <span class="comment">// 如果设置了setOnTouchListener 会截断(就跳过去了)onTouchEvent </span></div><div class="line">                  result = <span class="literal">true</span>;</div><div class="line">              &#125;</div><div class="line">      &#125;</div><div class="line">    <span class="keyword">return</span> result; </div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="View-onTouchEvent-伪代码"><a href="#View-onTouchEvent-伪代码" class="headerlink" title="View onTouchEvent 伪代码"></a>View onTouchEvent 伪代码</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</div><div class="line">  	<span class="comment">// 检查各种 clickable 如果有一个会 是true就会走</span></div><div class="line">    <span class="keyword">if</span> (((viewFlags &amp; CLICKABLE) == CLICKABLE ||</div><div class="line">            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||</div><div class="line">            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123;</div><div class="line">        <span class="keyword">switch</span> (action) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                ...</div><div class="line">                <span class="keyword">if</span>(!mHasPerformedLongPress)&#123;</div><div class="line">                <span class="comment">//longClick线程执行的时候会修改mHasPerformedLongPress=true;</span></div><div class="line">                <span class="comment">//所以longClick 和 click不会同时触发；</span></div><div class="line">                    removeLongPressCallback();  <span class="comment">// 移除长按</span></div><div class="line">                    ...</div><div class="line">                    performClick();             <span class="comment">// 检查单击</span></div><div class="line">                &#125;</div><div class="line">                ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">                mHasPerformedLongPress=<span class="keyword">false</span>;</div><div class="line">                ...</div><div class="line">                checkForLongClick(<span class="number">0</span>);       <span class="comment">// 检测长按 这是个延时线程如果没有被移除 就会执行；</span></div><div class="line">                ...</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;                        <span class="comment">// ◀︎表示事件被消费</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>摘自GcsSloop:<a href="http://www.gcssloop.com/customview/dispatch-touchevent-source" target="_blank" rel="external">http://www.gcssloop.com/customview/dispatch-touchevent-source</a></p>
</blockquote>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><blockquote>
<p>extend View</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">   ...</div><div class="line">   <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</div><div class="line">   ... </div><div class="line">   <span class="comment">//--------拦截判断--------</span></div><div class="line">   <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</div><div class="line">         <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</div><div class="line">                 || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//disallowIntercept与requestDisallowInterceptTouchEvent(boolean)方法有关；</span></div><div class="line">             <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</div><div class="line">             <span class="keyword">if</span> (!disallowIntercept) &#123;</div><div class="line">                 intercepted = onInterceptTouchEvent(ev);</div><div class="line">                 ev.setAction(action); <span class="comment">// restore action in case it was changed</span></div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 intercepted = <span class="keyword">false</span>;</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="comment">// There are no touch targets and this action is not an initial down</span></div><div class="line">             <span class="comment">// so this view group continues to intercept touches.</span></div><div class="line">             intercepted = <span class="keyword">true</span>;</div><div class="line">         &#125;  </div><div class="line">     <span class="comment">//--------拦截结束--------</span></div><div class="line">     </div><div class="line">     <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</div><div class="line">       <span class="comment">//没被拦截的情况</span></div><div class="line">       ...</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">           ...</div><div class="line">            <span class="comment">//如果有上一个dispatch返回true了 这个直接跳出for循环；</span></div><div class="line">            <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</div><div class="line">                   <span class="comment">// Child is already receiving touch within its bounds.</span></div><div class="line">                   <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></div><div class="line">                   newTouchTarget.pointerIdBits |= idBitsToAssign;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</div><div class="line">              <span class="comment">// Child wants to receive touch within its bounds.</span></div><div class="line">              mLastTouchDownTime = ev.getDownTime();</div><div class="line">              <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</div><div class="line">                  <span class="comment">// childIndex points into presorted list, find original index</span></div><div class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</div><div class="line">                      <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</div><div class="line">                          mLastTouchDownIndex = j;</div><div class="line">                          <span class="keyword">break</span>;</div><div class="line">                      &#125;</div><div class="line">                  &#125;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  mLastTouchDownIndex = childIndex;</div><div class="line">              &#125;</div><div class="line">              mLastTouchDownX = ev.getX();</div><div class="line">              mLastTouchDownY = ev.getY();</div><div class="line">              <span class="comment">//addTouchTarget方法里会给mFirstTouchTarget赋值；</span></div><div class="line">              newTouchTarget = addTouchTarget(child, idBitsToAssign);</div><div class="line">              alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</div><div class="line">              <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">       &#125;</div><div class="line">        ...</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">     <span class="comment">// Dispatch to touch targets.</span></div><div class="line">     <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123; </div><div class="line">         <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">         <span class="comment">//dispatchTransformedTouchEvent 因为传递null的view最后会走 super(就是view).dispatchTouchEvent()方法</span></div><div class="line">         handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</div><div class="line">                 TouchTarget.ALL_POINTER_IDS);</div><div class="line">     &#125; </div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> handled; </div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h1 id="Method之requestDisallowInterceptTouchEvent"><a href="#Method之requestDisallowInterceptTouchEvent" class="headerlink" title="Method之requestDisallowInterceptTouchEvent"></a>Method之requestDisallowInterceptTouchEvent</h1><blockquote>
<p>通过日志进行研究</p>
</blockquote>
<ul>
<li>已知:<ul>
<li>ReParent(就是ViewGroup): onTouchEvent,dispatchTouchEvent,onInterceptTouchEvent </li>
<li>ViewChild(就是View): onTouchEvent,dispatchTouchEvent</li>
</ul>
</li>
</ul>
<blockquote>
<p>return 的都是super.</p>
</blockquote>
<h2 id="开始测试："><a href="#开始测试：" class="headerlink" title="开始测试："></a>开始测试：</h2><ul>
<li><p>第一次 修改child  onTouchEvent return true </p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onInterceptTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>onTouchEvent ACTION_MOVE</div></pre></td></tr></table></figure>
<blockquote>
<p>说明 即使我消耗了,其父dispatch,onInterceptTouchEvent也会相继走,</p>
<p>而不是直接跳到目标View执行 dispatchTouchEvent,onTouchEvent 与传言不符~</p>
</blockquote>
</li>
<li><p>第二次 child dispatchTouchEvent return true </p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onInterceptTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div></pre></td></tr></table></figure>
<blockquote>
<p>为啥没走  ReParent-&gt;onTouchEvent ACTION_DOWN 因为 addTouchTarget(child, idBitsToAssign)是dispatchTouchEvent return true就执行 </p>
<p>会找到对应的目标;所以下面代码不走 </p>
</blockquote>
  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">源码</div><div class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="literal">null</span>) </div><div class="line">        <span class="comment">// No touch targets so treat this as an ordinary view.</span></div><div class="line">        handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>,</div><div class="line">                TouchTarget.ALL_POINTER_IDS);</div></pre></td></tr></table></figure>
</li>
<li><p>第三次：  child dispatchTouchEvent return true  但是我没有触碰到child </p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_DOWN</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onInterceptTouchEvent ACTION_DOWN</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onTouchEvent ACTION_DOWN</div></pre></td></tr></table></figure>
<blockquote>
<p>说明 第二次的源码是正确执行的;</p>
</blockquote>
</li>
<li><p><code>requestDisallowInterceptTouchEvent探究1</code></p>
<blockquote>
<p>把代码改回 child onTouchEvent return true dispatchTouchEvent return super.dispatchTouchEvent</p>
</blockquote>
<p>  测试源码</p>
  <figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN :</div><div class="line">    downX =event.getX();</div><div class="line">    <span class="keyword">Log</span>.i(<span class="built_in">TAG</span>, <span class="string">"ViewChild-&gt;onTouchEvent ACTION_DOWN"</span>);</div><div class="line">    break;</div><div class="line"><span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">    <span class="keyword">if</span>(Math.abs(event.getX()<span class="params">-downX</span>)&gt;<span class="number">200</span>)&#123;</div><div class="line">        <span class="keyword">Log</span>.i(<span class="built_in">TAG</span>, <span class="string">"ViewChild- &gt;200!!! 请求拦截"</span>);</div><div class="line">        getParent().requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">Log</span>.i(<span class="built_in">TAG</span>, <span class="string">"ViewChild- &lt;200!!! 父亲不拦截"</span>);</div><div class="line">        getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">Log</span>.i(<span class="built_in">TAG</span>, <span class="string">"ViewChild-&gt;onTouchEvent ACTION_MOVE"</span>);</div><div class="line">    break;</div></pre></td></tr></table></figure>
<p>  log:</p>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">ViewChild- &lt;<span class="number">200</span>!!! 父亲不拦截</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>onTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line"></div><div class="line">ViewChild- &gt;<span class="number">200</span>!!! 请求拦截</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>onTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onInterceptTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line"></div><div class="line">ViewChild- &lt;<span class="number">200</span>!!! 父亲不拦截</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>onTouchEvent ACTION_MOVE</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div><div class="line">V<span class="function"><span class="title">iewChild</span>-&gt;</span>dispatchTouchEvent ACTION_MOVE</div></pre></td></tr></table></figure>
</li>
<li><p><code>requestDisallowInterceptTouchEvent 探究2</code></p>
<blockquote>
<p>把ReParent onInterceptTouchEvent return true</p>
</blockquote>
  <figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>dispatchTouchEvent ACTION_DOWN</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onInterceptTouchEvent ACTION_DOWN</div><div class="line">R<span class="function"><span class="title">eParent</span>-&gt;</span>onTouchEvent ACTION_DOWN</div></pre></td></tr></table></figure>
<blockquote>
<p>说明 requestDisallowInterceptTouchEvent代码如果不走是不能让他停止拦截的；</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;研究分发流程,总结为伪代码便于理解,然后研究源码,最后探究Method之requestDisallowInterceptTouchEvent&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="事件传递" scheme="https://luhaoaimama1.github.io/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>Android-PorterDuffXfermode的正确使用方式</title>
    <link href="https://luhaoaimama1.github.io/2016/08/28/Xfermode/"/>
    <id>https://luhaoaimama1.github.io/2016/08/28/Xfermode/</id>
    <published>2016-08-28T05:19:37.000Z</published>
    <updated>2016-12-30T14:24:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>看这篇文章请确保看过本站的<strong>Android-Canvas</strong>这篇文章,主要理解其工作模式后会更容易理解;</p>
<a id="more"></a>
<h1 id="官方合成图"><a href="#官方合成图" class="headerlink" title="官方合成图"></a>官方合成图</h1><p><img src="https://ww2.sinaimg.cn/large/006tKfTcgw1fb8yigv0rqj30m80f8my1.jpg" alt=""></p>
<blockquote>
<p>如正确姿势的图，首先要明白的</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">解释2</th>
<th style="text-align:center">名字</th>
<th style="text-align:center">解释2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">黄色</td>
<td style="text-align:center">先画,下层(dst)</td>
<td style="text-align:center">in</td>
<td style="text-align:center">交集</td>
</tr>
<tr>
<td style="text-align:center">蓝色</td>
<td style="text-align:center">后画,上层(src)</td>
<td style="text-align:center">out</td>
<td style="text-align:center">不相交的</td>
</tr>
</tbody>
</table>
<blockquote>
<p>举例：PorterDuff.Mode.SRC_IN参数，表示的显示的是 SRC层 IN交集的部分(注意 <code>这其实是DST层</code> 下面有解释)；</p>
</blockquote>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb8yipzxu1j30rs0c13yr.jpg" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">解释2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">图2</td>
<td style="text-align:center"><code>创建两个Bitmap</code> <code>手机宽高</code> <code>bitmap上绘制圆</code> <code>如果看不懂看下面的代码</code></td>
</tr>
<tr>
<td style="text-align:center">图1</td>
<td style="text-align:center"><code>绘两个圆</code> <code>如果看不懂看下面的代码</code></td>
</tr>
</tbody>
</table>
<h1 id="核心原理-边界-："><a href="#核心原理-边界-：" class="headerlink" title="核心原理(边界)："></a>核心原理(边界)：</h1><blockquote>
<p>Xfermode效果:作用在 <code>两个边界之内</code>；<code>边界之外</code> <code>没有Xfermode效果</code>；</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">图</th>
<th style="text-align:center">边界</th>
<th style="text-align:center">SRC_IN</th>
<th style="text-align:center">SRC_OUT</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>图2</code> <code>正确姿势</code></td>
<td style="text-align:center">每个都是手机的宽高</td>
<td style="text-align:center">正确姿势图中的SRC_IN</td>
<td style="text-align:center">如正确姿势图中的 SRC_OUT</td>
</tr>
<tr>
<td style="text-align:center"><code>图1</code> <code>平时的误解</code></td>
<td style="text-align:center">每个都是绘的圆那么大</td>
<td style="text-align:center">如 <code>正确姿势图中的SRC_IN</code> <code>多出黄色的部分</code></td>
<td style="text-align:center">如 <code>正确姿势图中的SRC_OUT</code> <code>多出黄色的部分</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>正确姿势图 是官方给的图；</p>
<p>Tips:为什么多出黄色的部分？ 因为这个部分是 边界未相交的部分,那么不会有Xfermode的效果 所以剩下；</p>
<p><code>那么大家会很疑惑，为什么DST剩下了,SRC边界之外为何不剩下？</code></p>
<p>因为DST先绘制的 就是底图.SRC是为了给DST添加叠加模式的效果的.</p>
<p><code>最终显示的都是DST只是变成有叠加效果的DST；</code></p>
</blockquote>
<p><code>demo效果：动画、surfaceView、绘图方面的研究-&gt;Xfermode;然后选择模式；</code><br><a href="https://github.com/luhaoaimama1/zone-sdk/blob/master/Android_Zone_Test/src/com/example/mylib_test/activity/animal/viewa/XfermodeView.java" target="_blank" rel="external">xfermode代码</a></p>
<p>图1的代码：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">canvas.saveLayerAlpha(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), <span class="number">255</span>,</div><div class="line">            Canvas.ALL_SAVE_FLAG);</div><div class="line"></div><div class="line">    paint.setColor(Color.YELLOW);</div><div class="line">    canvas.drawCircle(getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, <span class="number">200</span>, paint);</div><div class="line">    paint.setXfermode(new PorterDuffXfermode(mode));</div><div class="line">    paint.setColor(Color.BLUE);</div><div class="line">    canvas.drawCircle(getWidth() / <span class="number">2</span> + <span class="number">200</span>, getHeight() / <span class="number">2</span> + <span class="number">200</span>, <span class="number">200</span>, paint);</div></pre></td></tr></table></figure></p>
<p>图2的代码：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//画黄色的圆 满屏幕那种 <span class="keyword">bitmap</span></div><div class="line"><span class="keyword">Bitmap </span><span class="keyword">bt </span>= <span class="keyword">Bitmap.createBitmap(getWidth(), </span>getHeight(), <span class="keyword">Bitmap.Config.ARGB_4444);</span></div><div class="line"><span class="symbol">canvas2.setBitmap</span>(<span class="keyword">bt);</span></div><div class="line"><span class="symbol">paint.setColor</span>(Color.YELLOW)<span class="comment">;</span></div><div class="line"><span class="symbol">canvas2.drawCircle</span>(getWidth() / <span class="number">2</span>, getHeight() / <span class="number">2</span>, <span class="number">200</span>, paint)<span class="comment">;</span></div><div class="line">//画蓝色的圆 满屏幕那种 <span class="keyword">bitmap</span></div><div class="line"><span class="keyword">Bitmap </span><span class="keyword">bt2 </span>= <span class="keyword">Bitmap.createBitmap(getWidth(), </span>getHeight(), <span class="keyword">Bitmap.Config.ARGB_4444);</span></div><div class="line"><span class="symbol">canvas2.setBitmap</span>(<span class="keyword">bt2);</span></div><div class="line"><span class="symbol">paint.setColor</span>(Color.<span class="keyword">BLUE);</span></div><div class="line"><span class="symbol">canvas2.drawCircle</span>(getWidth() / <span class="number">2</span> + <span class="number">200</span>, getHeight() / <span class="number">2</span> + <span class="number">200</span>, <span class="number">200</span>, paint)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<h1 id="问题延伸"><a href="#问题延伸" class="headerlink" title="问题延伸"></a>问题延伸</h1><h2 id="为什么-不用saveLayerAlpha有时候就不好使"><a href="#为什么-不用saveLayerAlpha有时候就不好使" class="headerlink" title="为什么 不用saveLayerAlpha有时候就不好使"></a>为什么 不用saveLayerAlpha有时候就不好使</h2><p><a href="http://blog.csdn.net/harvic880925/article/details/51317746" target="_blank" rel="external">harvic博客解释了为什么不用saveLayerAlpha有时候就不好使?</a></p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int layerID = canvas.saveLayer(<span class="number">0</span>, <span class="number">0</span>, width * <span class="number">2</span>, height * <span class="number">2</span>, mPaint, Canvas.ALL_SAVE_FLAG);</div><div class="line">canvas.drawBitmap(dstBmp, <span class="number">0</span>, <span class="number">0</span>, mPaint);</div><div class="line">mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));</div><div class="line">canvas.drawBitmap(srcBmp, width / <span class="number">2</span>, height / <span class="number">2</span>, mPaint);</div></pre></td></tr></table></figure>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb8ygjcf7ij30uy092mx6.jpg" alt=""></p>
<h2 id="有saveLayer的绘图流程"><a href="#有saveLayer的绘图流程" class="headerlink" title="有saveLayer的绘图流程"></a><strong>有saveLayer的绘图流程</strong></h2><p>这是因为在调用saveLayer时，会生成了一个全新的bitmap，这个bitmap的大小就是我们指定的保存区域的大小，新生成的bitmap是全透明的，在调用saveLayer后所有的绘图操作都是在这个bitmap上进行的。<br><img src="https://ww3.sinaimg.cn/large/006tKfTcgw1fb8yiwcm8bj30f008umx5.jpg" alt=""></p>
<h2 id="没有saveLayer的绘图流程"><a href="#没有saveLayer的绘图流程" class="headerlink" title="没有saveLayer的绘图流程"></a><strong>没有saveLayer的绘图流程</strong></h2><p>由于我们先把整个画布给染成了绿色，然后再画上了一个圆形，所以在应用xfermode来画源图像的时候，目标图像当前Bitmap上的所有图像了，也就是整个绿色的屏幕和一个圆形了。所以这时候源图像的相交区域是没有透明像素的，透明度全是100%，这也就不难解释结果是这样的原因了。<br><img src="https://ww4.sinaimg.cn/large/006tKfTcgw1fb8yj3233oj30fu09ga9z.jpg" alt=""></p>
<blockquote>
<p>总结就是  saveLayer为了区分，哪一步的图形,应该与合成模式的bitmap去合成 运算；</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看这篇文章请确保看过本站的&lt;strong&gt;Android-Canvas&lt;/strong&gt;这篇文章,主要理解其工作模式后会更容易理解;&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
      <category term="PorterDuffXfermode" scheme="https://luhaoaimama1.github.io/tags/PorterDuffXfermode/"/>
    
  </entry>
  
  <entry>
    <title>Android疑难问题汇总</title>
    <link href="https://luhaoaimama1.github.io/2016/07/13/Java%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://luhaoaimama1.github.io/2016/07/13/Java疑难问题汇总/</id>
    <published>2016-07-13T05:19:37.000Z</published>
    <updated>2017-03-14T07:14:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续收集ing 敬请留言~</p>
<a id="more"></a>
<ul>
<li><p>当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递? </p>
<ul>
<li>基本类型: 按值传递。既传递值的副本。实际两个对象  </li>
<li>对象数组: 按值传递。传递 引用的副本。实际一个对象<blockquote>
<p>Tips:数组需要注意的地方</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">handValue(<span class="keyword">sort</span>[<span class="number">1</span>]);<span class="comment">//传递的是sort[1]值的副本</span></div><div class="line">handValue2(<span class="keyword">sort</span>);<span class="comment">//传递的是sort的引用的副本</span></div></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续收集ing 敬请留言~&lt;/p&gt;
    
    </summary>
    
      <category term="android" scheme="https://luhaoaimama1.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://luhaoaimama1.github.io/tags/android/"/>
    
  </entry>
  
</feed>
